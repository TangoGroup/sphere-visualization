{"version":3,"file":"index.mjs","sources":["../node_modules/react/cjs/react-jsx-runtime.production.js","../node_modules/react/cjs/react-jsx-runtime.development.js","../node_modules/react/jsx-runtime.js","../src/utils/fibonacciSphere.ts","../src/components/SphereWaveform.tsx","../src/animation/easing.ts","../src/animation/useMorphAnimator.ts"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = require(\"react\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !1,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.jsxs = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !0,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","export interface FibonacciSphereResult {\n  positions: Float32Array;\n  seeds: Float32Array;\n}\n\nexport function generateFibonacciSpherePoints(\n  vertexCount: number,\n  radius: number,\n  seed: number = 1\n): FibonacciSphereResult {\n  const count = Math.max(1, Math.floor(Number.isFinite(vertexCount) ? vertexCount : 1));\n  const r = Number.isFinite(radius) ? radius : 1;\n  const phi = (1 + Math.sqrt(5)) / 2;\n  const goldenAngle = (2 - phi) * (2 * Math.PI);\n\n  const positions = new Float32Array(count * 3);\n  const seeds = new Float32Array(count);\n\n  for (let i = 0; i < count; i += 1) {\n    const t = i + 0.5;\n    const y = 1 - (t / Math.max(1, count)) * 2; // y from 1 to -1\n    const yy = Math.min(1, Math.max(-1, y));\n    const radiusAtY = Math.sqrt(Math.max(0, 1 - yy * yy));\n    const theta = goldenAngle * t;\n\n    const x = Math.cos(theta) * radiusAtY;\n    const z = Math.sin(theta) * radiusAtY;\n\n    positions[i * 3 + 0] = x * r;\n    positions[i * 3 + 1] = yy * r;\n    positions[i * 3 + 2] = z * r;\n\n    // simple LCG-based pseudo-random per-vertex seed but deterministic by index and seed param\n    const pr = lcg(i + 1, seed);\n    seeds[i] = pr;\n  }\n\n  return { positions, seeds };\n}\n\nfunction lcg(index: number, seed: number): number {\n  // Deterministic [0,1) based on index and seed\n  const a = 1664525;\n  const c = 1013904223;\n  let state = (seed ^ (index * 2654435761)) >>> 0;\n  state = (Math.imul(a, state) + c) >>> 0;\n  return (state & 0xffffffff) / 0x100000000;\n}\n","import { useEffect, useMemo, useRef } from 'react';\nimport * as THREE from 'three';\nimport { useFrame } from '@react-three/fiber';\nimport { generateFibonacciSpherePoints } from '../utils/fibonacciSphere';\n\n// Removed WaveState - using individual toggles instead\n\nexport interface SphereWaveformProps {\n  vertexCount?: number;\n  volume: number; // 0..1\n  radius?: number; // default 1\n  pointSize?: number; // default 0.04 logical px\n  shellCount?: number; // default 1, number of nested spheres\n  seed?: number; // layout randomness\n  freezeTime?: boolean; // debug: freeze time progression\n  advanceCount?: number; // debug: increments to step time forward manually\n  advanceAmount?: number; // seconds to advance per count (default 1/60)\n  // Global transform\n  size?: number; // overall scene scale multiplier (default 1)\n  opacity?: number; // 0..1 global alpha multiplier\n  rotationX?: number; // degrees\n  rotationY?: number; // degrees\n  rotationZ?: number; // degrees\n  // Composable noise toggles\n  enableRandomishNoise?: boolean;\n  randomishAmount?: number; // 0..1\n  enableSineNoise?: boolean;\n  sineAmount?: number; // 0..1\n  randomishSpeed?: number; // time multiplier for randomish noise\n  pulseSize?: number; // 0..1, controls amplitude of pulse state\n  // Ripple noise specific controls\n  enableRippleNoise?: boolean;\n  rippleAmount?: number; // 0..1\n  rippleSpeed?: number; // 0.1..10\n  rippleScale?: number; // cycles across surface\n  // New toggle-based controls\n  enableSurfaceRipple?: boolean;\n  surfaceRippleAmount?: number;\n  surfaceRippleSpeed?: number;\n  surfaceRippleScale?: number;\n  enableSpin?: boolean;\n  spinSpeed?: number;\n  // Spin axis controls\n  spinAxisX?: number;\n  spinAxisY?: number;\n  // Screen-space circular gradient mask controls\n  maskEnabled?: boolean;\n  // In [0,1], relative to half of the smaller screen dimension (0.5 ~ quarter of min dimension radius)\n  maskRadius?: number;\n  // In [0,1], feather width relative to half of the smaller screen dimension\n  maskFeather?: number;\n  // If true, keeps outside and occludes inside\n  maskInvert?: boolean;\n  // Sine noise specific controls\n  sineSpeed?: number; // temporal frequency multiplier\n  sineScale?: number; // scales aSeed phase contribution\n  // Appearance\n  pointColor?: string; // hex\n  glowColor?: string; // hex for glow\n  glowStrength?: number; // 0..3\n  glowRadiusFactor?: number; // per-side halo thickness as multiple of core radius\n  // Gradient coloring\n  enableGradient?: boolean;\n  gradientColor2?: string;\n  gradientAngle?: number; // degrees 0..360\n  // glowSoftness removed in v20\n  // Point size randomness\n  sizeRandomness?: number; // 0..1 mixes base size with random [0..2]\n  // Arcs (great-circle segments)\n  enableArcs?: boolean;\n  arcMaxCount?: number;\n  arcSpawnRate?: number;\n  arcDuration?: number;\n  arcSpeed?: number;\n  arcSpanDeg?: number;\n  arcThickness?: number;\n  arcFeather?: number;\n  arcBrightness?: number;\n  arcAltitude?: number;\n  // Rendering mode\n  blendingMode?: 'additive' | 'normal';\n  // Modulation sources\n  micEnvelope?: number; // 0..1\n  randomishMicModAmount?: number; // 0..1\n  sineMicModAmount?: number; // 0..1\n  rippleMicModAmount?: number; // 0..1\n  surfaceRippleMicModAmount?: number; // 0..1\n  // Auto-transition of animatable props\n  transition?: TransitionOptions;\n  // Dual-state morphing: compute A and B lanes in-shader and blend by progress\n  morph?: {\n    enabled?: boolean;\n    progress?: number; // 0..1\n    to?: Partial<SphereWaveformProps>;\n  };\n}\n\ninterface Uniforms {\n  uTime: { value: number };\n  uVolume: { value: number };\n  uRadius: { value: number };\n  uRadius2: { value: number };\n  uPointSize: { value: number };\n  uPointSize2: { value: number };\n  uPixelRatio: { value: number };\n  uViewportWidth: { value: number };\n  uViewportHeight: { value: number };\n  uFov: { value: number }; // radians\n  uShellPhase: { value: number };\n  uEnableRandomish: { value: number };\n  uRandomishAmount: { value: number };\n  uRandomishAmount2: { value: number };\n  uEnableSine: { value: number };\n  uSineAmount: { value: number };\n  uSineAmount2: { value: number };\n  uRandomishSpeed: { value: number };\n  uRandomishSpeed2: { value: number };\n  uPulseSize: { value: number };\n  uPulseSize2: { value: number };\n  uOpacity: { value: number };\n  // Size randomness\n  uSizeRandomness: { value: number };\n  // Halo expansion\n  uGlowRadiusFactor: { value: number };\n  uGlowRadiusFactor2: { value: number };\n  // uGlowSoftness removed\n  uExpandHalo: { value: number };\n  // Ripple uniforms\n  uEnableRipple: { value: number };\n  uRippleAmount: { value: number };\n  uRippleAmount2: { value: number };\n  uRippleSpeed: { value: number };\n  uRippleSpeed2: { value: number };\n  uRippleScale: { value: number };\n  uRippleScale2: { value: number };\n  // Surface ripple (tangent displacement)\n  uEnableSurfaceRipple: { value: number };\n  uSurfaceRippleAmount: { value: number };\n  uSurfaceRippleAmount2: { value: number };\n  uSurfaceRippleSpeed: { value: number };\n  uSurfaceRippleSpeed2: { value: number };\n  uSurfaceRippleScale: { value: number };\n  uSurfaceRippleScale2: { value: number };\n  uSurfaceCenter: { value: THREE.Vector3 };\n  // New toggle-based uniforms\n  uEnableSpin: { value: number };\n  uSpinSpeed: { value: number };\n  uSpinSpeed2: { value: number };\n  // Spin axis uniforms\n  uSpinAxisX: { value: number };\n  uSpinAxisY: { value: number };\n  uSpinAxisX2: { value: number };\n  uSpinAxisY2: { value: number };\n  // Screen-space mask uniforms\n  uMaskEnabled: { value: number };\n  uMaskRadiusPx: { value: number };\n  uMaskFeatherPx: { value: number };\n  uMaskInvert: { value: number };\n  uMaskCenterNdc: { value: THREE.Vector2 };\n  // Sine noise uniforms\n  uSineSpeed: { value: number };\n  uSineScale: { value: number };\n  uSineSpeed2: { value: number };\n  uSineScale2: { value: number };\n  // Appearance\n  uColor: { value: THREE.Color };\n  uGlowColor: { value: THREE.Color };\n  uGlowStrength: { value: number };\n  // Gradient\n  uEnableGradient: { value: number };\n  uColor2: { value: THREE.Color };\n  uGradientAngle: { value: number };\n  // Arcs\n  uArcsActive: { value: number };\n  uArcCenters: { value: Float32Array };\n  uArcTangents: { value: Float32Array };\n  uArcT0: { value: Float32Array };\n  uArcDur: { value: Float32Array };\n  uArcSpeed: { value: Float32Array };\n  uArcSpan: { value: Float32Array };\n  uArcThick: { value: Float32Array };\n  uArcFeather: { value: Float32Array };\n  uArcBright: { value: Float32Array };\n  uArcAltitude: { value: number };\n  // Morph blending\n  uMorphProgress: { value: number };\n}\n\nconst vertexShader = /* glsl */ `\nprecision highp float;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uVolume;\nuniform float uRadius;\nuniform float uRadius2;\nuniform float uPointSize;\nuniform float uPointSize2;\nuniform float uPixelRatio;\nuniform float uViewportWidth;\nuniform float uViewportHeight;\nuniform float uFov;\nuniform float uShellPhase;\nuniform float uSizeRandomness;\nuniform float uGlowRadiusFactor;\nuniform float uGlowRadiusFactor2;\n// softness removed\nuniform int uEnableRandomish;\nuniform float uRandomishAmount;\nuniform float uRandomishAmount2;\nuniform int uEnableSine;\nuniform float uSineAmount;\nuniform float uSineAmount2;\nuniform float uRandomishSpeed;\nuniform float uRandomishSpeed2;\nuniform float uSineSpeed;\nuniform float uSineScale;\nuniform float uSineSpeed2;\nuniform float uSineScale2;\nuniform float uPulseSize;\nuniform float uPulseSize2;\nuniform int uEnableRipple;\nuniform float uRippleAmount;\nuniform float uRippleAmount2;\nuniform float uRippleSpeed;\nuniform float uRippleSpeed2;\nuniform float uRippleScale;\nuniform float uRippleScale2;\nuniform int uEnableSurfaceRipple;\nuniform float uSurfaceRippleAmount;\nuniform float uSurfaceRippleAmount2;\nuniform float uSurfaceRippleSpeed;\nuniform float uSurfaceRippleSpeed2;\nuniform float uSurfaceRippleScale;\nuniform float uSurfaceRippleScale2;\nuniform vec3 uSurfaceCenter;\n// Arcs\nconst int MAX_ARCS = 8;\nuniform int uArcsActive;\nuniform vec3 uArcCenters[MAX_ARCS];\nuniform vec3 uArcTangents[MAX_ARCS];\nuniform float uArcT0[MAX_ARCS];\nuniform float uArcDur[MAX_ARCS];\nuniform float uArcSpeed[MAX_ARCS];\nuniform float uArcSpan[MAX_ARCS];\nuniform float uArcThick[MAX_ARCS];\nuniform float uArcFeather[MAX_ARCS];\nuniform float uArcBright[MAX_ARCS];\nuniform float uArcAltitude;\n// New toggle-based uniforms\nuniform int uEnableSpin;\nuniform float uSpinSpeed;\nuniform float uSpinSpeed2;\n// Spin axis uniforms\nuniform float uSpinAxisX;\nuniform float uSpinAxisY;\nuniform float uSpinAxisX2;\nuniform float uSpinAxisY2;\n// Gradient coloring\nuniform int uEnableGradient;\nuniform float uGradientAngle; // radians\nuniform float uMorphProgress; // 0..1\n\nvarying vec2 vNdc;\nvarying float vArcBoost;\nvarying float vSizeRand;\nvarying float vCoreRadiusNorm;\nvarying float vGradT;\n\n// Simple hash function for deterministic pseudo-random values\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\nfloat hash(vec3 p) { return hash(dot(p, vec3(127.1, 311.7, 74.7))); }\n\n// Smooth interpolation\nfloat smoothNoise(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  \n  float a = hash(i);\n  float b = hash(i + vec3(1.0, 0.0, 0.0));\n  float c = hash(i + vec3(0.0, 1.0, 0.0));\n  float d = hash(i + vec3(1.0, 1.0, 0.0));\n  float e = hash(i + vec3(0.0, 0.0, 1.0));\n  float f1 = hash(i + vec3(1.0, 0.0, 1.0));\n  float g = hash(i + vec3(0.0, 1.0, 1.0));\n  float h = hash(i + vec3(1.0, 1.0, 1.0));\n  \n  return mix(\n    mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n    mix(mix(e, f1, f.x), mix(g, h, f.x), f.y),\n    f.z\n  );\n}\n\nvoid main() {\n  vec3 initialBase = normalize(position);\n  vec3 baseA = initialBase;\n  vec3 baseB = initialBase;\n\n  // Spin rotates around custom axis when enabled\n  if (uEnableSpin > 0) {\n    float spinAngleA = uTime * uSpinSpeed;\n    float spinAngleB = uTime * uSpinSpeed2;\n    \n    // Convert axis angles to a normalized rotation axis vector\n    // We'll use the axis angles to define the rotation axis\n    float xRadA = radians(uSpinAxisX);\n    float yRadA = radians(uSpinAxisY);\n    float xRadB = radians(uSpinAxisX2);\n    float yRadB = radians(uSpinAxisY2);\n    \n    // Create a rotation axis from the angles\n    // This creates a unit vector pointing in the direction of the rotation axis\n    vec3 axisA = normalize(vec3(\n      sin(yRadA),\n      sin(xRadA),\n      cos(xRadA) * cos(yRadA)\n    ));\n    vec3 axisB = normalize(vec3(\n      sin(yRadB),\n      sin(xRadB),\n      cos(xRadB) * cos(yRadB)\n    ));\n    \n    // Rodrigues' rotation formula to rotate around the custom axis\n    float cA = cos(spinAngleA);\n    float sA = sin(spinAngleA);\n    float omcA = 1.0 - cA; // one minus cosine\n    float cB = cos(spinAngleB);\n    float sB = sin(spinAngleB);\n    float omcB = 1.0 - cB; // one minus cosine\n    \n    // Rotation matrix for rotation around arbitrary axis\n    mat3 RA = mat3(\n      axisA.x * axisA.x * omcA + cA,\n      axisA.x * axisA.y * omcA - axisA.z * sA,\n      axisA.x * axisA.z * omcA + axisA.y * sA,\n      axisA.y * axisA.x * omcA + axisA.z * sA,\n      axisA.y * axisA.y * omcA + cA,\n      axisA.y * axisA.z * omcA - axisA.x * sA,\n      axisA.z * axisA.x * omcA - axisA.y * sA,\n      axisA.z * axisA.y * omcA + axisA.x * sA,\n      axisA.z * axisA.z * omcA + cA\n    );\n    mat3 RB = mat3(\n      axisB.x * axisB.x * omcB + cB,\n      axisB.x * axisB.y * omcB - axisB.z * sB,\n      axisB.x * axisB.z * omcB + axisB.y * sB,\n      axisB.y * axisB.x * omcB + axisB.z * sB,\n      axisB.y * axisB.y * omcB + cB,\n      axisB.y * axisB.z * omcB - axisB.x * sB,\n      axisB.z * axisB.x * omcB - axisB.y * sB,\n      axisB.z * axisB.y * omcB + axisB.x * sB,\n      axisB.z * axisB.z * omcB + cB\n    );\n    \n    // Apply the rotation\n    baseA = RA * baseA;\n    baseB = RB * baseB;\n  }\n\n  // Base time\n  float t = uTime * 0.4 + uShellPhase;\n  \n  float nRandomish = 0.0;\n  if (uEnableRandomish > 0) {\n    float spatialScale = mix(0.5, 10.0, uPulseSize);\n    float tR = t * uRandomishSpeed;\n    vec3 p = baseA * spatialScale + vec3(aSeed * 0.1, aSeed * 0.2, tR);\n    nRandomish = (smoothNoise(p) * 2.0 - 1.0) * uRandomishAmount;\n  }\n  float nSine = 0.0;\n  if (uEnableSine > 0) {\n    nSine = sin(t * uSineSpeed + aSeed * 6.2831853 * uSineScale) * uSineAmount;\n  }\n  // Ripple along surface: traveling wave around Z axis using longitude\n  float nRipple = 0.0;\n  if (uEnableRipple > 0) {\n    float tR = t * uRippleSpeed;\n    float longitude = atan(baseA.y, baseA.x); // [-pi, pi]\n    float wave = sin(longitude * uRippleScale - tR);\n    nRipple = wave * uRippleAmount;\n  }\n  // Surface ripple displacement along tangent directions (keeps radius ~constant)\n  vec3 tangentDisplaced = vec3(0.0);\n  if (uEnableSurfaceRipple > 0) {\n    vec3 N = normalize(baseA);\n    // Geodesic angle from moving center\n    float angle = acos(clamp(dot(N, normalize(uSurfaceCenter)), -1.0, 1.0));\n    float phase = angle * uSurfaceRippleScale - t * uSurfaceRippleSpeed;\n    float wave = sin(phase);\n    // Tangent direction towards center along the surface\n    vec3 toCenterTangent = normalize(uSurfaceCenter - dot(uSurfaceCenter, N) * N);\n    // In case of degeneracy near alignment, fall back to arbitrary tangent\n    if (!all(greaterThan(abs(toCenterTangent), vec3(1e-6)))) {\n      vec3 alt = vec3(1.0, 0.0, 0.0);\n      toCenterTangent = normalize(cross(N, cross(alt, N)));\n    }\n    vec3 offset = toCenterTangent * (wave * uSurfaceRippleAmount * 0.25);\n    vec3 surf = normalize(baseA + offset);\n    tangentDisplaced = surf - baseA;\n  }\n  float n = nRandomish + nSine + nRipple;\n\n  // Map n in [-1,1] to multiplicative radius: 1 + n*volume\n  float radialFactorA = 1.0 + n * clamp(uVolume, 0.0, 1.0);\n  radialFactorA = clamp(radialFactorA, 0.0, 2.5);\n  vec3 displacedA = (baseA + tangentDisplaced) * (uRadius * radialFactorA);\n\n  // Lane B\n  float nRandomishB = 0.0;\n  float nSineB = 0.0;\n  float nRippleB = 0.0;\n  vec3 tangentDisplacedB = vec3(0.0);\n  if (uEnableRandomish > 0) {\n    float spatialScaleB = mix(0.5, 10.0, uPulseSize2);\n    float tRB = t * uRandomishSpeed2;\n    vec3 pB = baseB * spatialScaleB + vec3(aSeed * 0.1, aSeed * 0.2, tRB);\n    nRandomishB = (smoothNoise(pB) * 2.0 - 1.0) * uRandomishAmount2;\n  }\n  if (uEnableSine > 0) {\n    nSineB = sin(t * uSineSpeed2 + aSeed * 6.2831853 * uSineScale2) * uSineAmount2;\n  }\n  if (uEnableRipple > 0) {\n    float tRB = t * uRippleSpeed2;\n    float longitudeB = atan(baseB.y, baseB.x);\n    float waveB = sin(longitudeB * uRippleScale2 - tRB);\n    nRippleB = waveB * uRippleAmount2;\n  }\n  if (uEnableSurfaceRipple > 0) {\n    vec3 N2 = normalize(baseB);\n    float angle2 = acos(clamp(dot(N2, normalize(uSurfaceCenter)), -1.0, 1.0));\n    float phase2 = angle2 * uSurfaceRippleScale2 - t * uSurfaceRippleSpeed2;\n    float wave2 = sin(phase2);\n    vec3 toCenterTangent2 = normalize(uSurfaceCenter - dot(uSurfaceCenter, N2) * N2);\n    if (!all(greaterThan(abs(toCenterTangent2), vec3(1e-6)))) {\n      vec3 alt2 = vec3(1.0, 0.0, 0.0);\n      toCenterTangent2 = normalize(cross(N2, cross(alt2, N2)));\n    }\n    vec3 offset2 = toCenterTangent2 * (wave2 * uSurfaceRippleAmount2 * 0.25);\n    vec3 surf2 = normalize(baseB + offset2);\n    tangentDisplacedB = surf2 - baseB;\n  }\n  float nB = nRandomishB + nSineB + nRippleB;\n  float radialFactorB = 1.0 + nB * clamp(uVolume, 0.0, 1.0);\n  radialFactorB = clamp(radialFactorB, 0.0, 2.5);\n  vec3 displacedB = (baseB + tangentDisplacedB) * (uRadius2 * radialFactorB);\n\n  float s = clamp(uMorphProgress, 0.0, 1.0);\n  // Spherical interpolation between lane directions to avoid passing through the origin\n  vec3 dirA = normalize(baseA + tangentDisplaced);\n  vec3 dirB = normalize(baseB + tangentDisplacedB);\n  float dotAB = clamp(dot(dirA, dirB), -1.0, 1.0);\n  float theta = acos(dotAB);\n  vec3 dir;\n  if (theta < 1e-4) {\n    dir = dirA;\n  } else {\n    float sinTheta = sin(theta);\n    float wA = sin((1.0 - s) * theta) / sinTheta;\n    float wB = sin(s * theta) / sinTheta;\n    dir = normalize(wA * dirA + wB * dirB);\n  }\n  float radiusMix = mix(uRadius * radialFactorA, uRadius2 * radialFactorB, s);\n  vec3 displaced = dir * radiusMix;\n  vec3 base = dir;\n\n  // Arcs influence: accumulate alpha boost and small radial puff\n  vArcBoost = 0.0;\n  if (uArcsActive > 0) {\n    for (int i = 0; i < MAX_ARCS; i++) {\n      if (i >= uArcsActive) { continue; }\n      float age = uTime - uArcT0[i];\n      if (age < 0.0 || age > uArcDur[i]) { continue; }\n      float tnorm = clamp(age / max(0.0001, uArcDur[i]), 0.0, 1.0);\n      // Temporal fade in/out\n      float fade = smoothstep(0.0, 0.2, tnorm) * (1.0 - smoothstep(0.8, 1.0, tnorm));\n      // Great-circle param along arc\n      vec3 C = normalize(uArcCenters[i]);\n      vec3 T = normalize(uArcTangents[i]);\n      vec3 B = cross(C, T);\n      vec3 Np = normalize(base - dot(base, C) * C);\n      float phi = atan(dot(Np, B), dot(Np, T));\n      float phiHead = -tnorm * uArcSpeed[i];\n      float halfSpan = uArcSpan[i] * 0.5;\n      float centerDist = abs(atan(sin(phi - phiHead), cos(phi - phiHead)));\n      float withinSpan = 1.0 - smoothstep(halfSpan, halfSpan + uArcFeather[i], centerDist);\n      float planeDist = abs(dot(base, C));\n      float withinThick = 1.0 - smoothstep(uArcThick[i], uArcThick[i] + uArcFeather[i], planeDist);\n      // Altitude profile along arc length: 0 at ends, 1 at center\n      float along = clamp(1.0 - centerDist / max(1e-4, halfSpan), 0.0, 1.0);\n      float altShape = sin(along * 3.14159265); // 0..1..0\n      float mask = withinSpan * withinThick * fade;\n      if (mask > 0.0) {\n        vArcBoost += mask * uArcBright[i];\n        // Altitude measured in multiples of sphere radius (uRadius)\n        displaced += base * (uArcAltitude * uRadius * altShape * withinThick * fade);\n      }\n    }\n  }\n\n  vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n  gl_Position = projectionMatrix * mvPosition;\n  vNdc = gl_Position.xy / gl_Position.w;\n\n  // FOV-correct perspective size attenuation\n  float scale = uViewportHeight / (2.0 * tan(uFov * 0.5));\n  // Per-vertex size randomness: [0..2] factor mixed by uSizeRandomness\n  float rand01 = hash(aSeed);\n  float sizeFactor = mix(1.0, rand01 * 2.0, clamp(uSizeRandomness, 0.0, 1.0));\n  vSizeRand = sizeFactor;\n  float pointSizeMix = mix(uPointSize, uPointSize2, s);\n  float glowMix = mix(uGlowRadiusFactor, uGlowRadiusFactor2, s);\n  float basePx = (pointSizeMix * sizeFactor) * uPixelRatio * scale / -mvPosition.z;\n  float haloPx = max(0.0, glowMix) * basePx;\n  float expanded = basePx + 2.0 * haloPx;\n  vCoreRadiusNorm = (expanded > 0.0) ? clamp(basePx / expanded, 0.0, 1.0) : 1.0;\n  gl_PointSize = clamp(expanded, 0.0, 2048.0);\n  // Compute gradient mix factor from original static position so color is stable\n  if (uEnableGradient > 0) {\n    float ang = uGradientAngle; // radians\n    // 3D direction around Y axis (full great-circle variation)\n    vec3 dir3 = normalize(vec3(cos(ang), 0.0, sin(ang)));\n    float proj = dot(normalize(initialBase), dir3);\n    vGradT = clamp(proj * 0.5 + 0.5, 0.0, 1.0);\n  } else {\n    vGradT = 0.0;\n  }\n}\n`;\n\nconst fragmentShader = /* glsl */ `\nprecision highp float;\nuniform float uViewportWidth;\nuniform float uViewportHeight;\nuniform int uMaskEnabled;\nuniform float uMaskRadiusPx;\nuniform float uMaskFeatherPx;\nuniform int uMaskInvert;\nuniform vec2 uMaskCenterNdc;\nuniform vec3 uColor;\nuniform vec3 uColor2;\nuniform int uEnableGradient;\nuniform float uOpacity;\nuniform vec3 uGlowColor;\nuniform float uGlowStrength;\nvarying vec2 vNdc;\nvarying float vArcBoost;\nvarying float vSizeRand;\nvarying float vCoreRadiusNorm;\nvarying float vGradT;\nvoid main() {\n  vec2 uv = gl_PointCoord * 2.0 - 1.0;\n  float r2 = dot(uv, uv);\n  float r = sqrt(r2);\n  // Discard square sprite corners so depth writes don't clip as boxes\n  if (r > 1.0) { discard; }\n  // Core disc alpha with a thicker feather to avoid precision artifacts\n  float alpha = 1.0 - smoothstep(vCoreRadiusNorm, vCoreRadiusNorm + 0.05, r);\n  // Screen-space circular mask shared by color and alpha\n  float screenMask = 1.0;\n  if (uMaskEnabled > 0) {\n    // Pixel-space distance to mask center (attached to sphere center in NDC)\n    vec2 deltaPx = vec2((vNdc.x - uMaskCenterNdc.x) * 0.5 * uViewportWidth, (vNdc.y - uMaskCenterNdc.y) * 0.5 * uViewportHeight);\n    float distPx = length(deltaPx);\n    float inside = 1.0 - smoothstep(uMaskRadiusPx, uMaskRadiusPx + max(0.0001, uMaskFeatherPx), distPx);\n    screenMask = (uMaskInvert > 0) ? (1.0 - inside) : inside;\n    alpha *= clamp(screenMask, 0.0, 1.0);\n  }\n  alpha *= min(3.0, 1.0 + vArcBoost);\n  alpha *= clamp(uOpacity, 0.0, 1.0);\n  // Edge ring emission to tint bloom without altering core opacity\n  float inner = vCoreRadiusNorm;\n  float end = mix(inner, 1.0, 0.3);\n  float ring = 1.0 - smoothstep(inner, end, r);\n  float emission = ring * clamp(uGlowStrength, 0.0, 3.0);\n  vec3 baseColor = (uEnableGradient > 0) ? mix(uColor, uColor2, clamp(vGradT, 0.0, 1.0)) : uColor;\n  vec3 color = (baseColor + uGlowColor * emission * 0.4) * screenMask;\n  float outAlpha = alpha;\n  gl_FragColor = vec4(color, outAlpha);\n}\n`;\n\n// Removed getMode function - using toggles instead\n\ntype Arc = {\n  center: THREE.Vector3;\n  tangent: THREE.Vector3;\n  t0: number;\n  duration: number;\n  speed: number;\n  span: number;\n  thickness: number;\n  feather: number;\n  brightness: number;\n};\n\ntype AnimEase =\n  | 'linear'\n  | 'power1.in' | 'power1.out' | 'power1.inOut'\n  | 'power2.in' | 'power2.out' | 'power2.inOut'\n  | 'power3.in' | 'power3.out' | 'power3.inOut'\n  | 'power4.in' | 'power4.out' | 'power4.inOut'\n  | 'sine.in' | 'sine.out' | 'sine.inOut'\n  | 'expo.in' | 'expo.out' | 'expo.inOut'\n  | 'back.in' | 'back.out' | 'back.inOut'\n  | 'elastic.in' | 'elastic.out' | 'elastic.inOut'\n  | 'bounce.in' | 'bounce.out' | 'bounce.inOut';\n\nexport interface TransitionOptions {\n  enabled?: boolean;\n  mode?: 'lerp';\n  duration?: number; // seconds\n  ease?: AnimEase;\n  onStart?: () => void;\n  onComplete?: () => void;\n}\n\nfunction getEaser(name: AnimEase | undefined): (t: number) => number {\n  switch (name) {\n    case 'linear':\n      return (t: number) => t;\n    case 'power1.in':\n      return (t: number) => t * t;\n    case 'power1.out':\n      return (t: number) => 1 - Math.pow(1 - t, 2);\n    case 'power1.inOut':\n      return (t: number) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);\n    case 'power2.in':\n      return (t: number) => t * t * t;\n    case 'power2.out':\n      return (t: number) => 1 - Math.pow(1 - t, 3);\n    case 'power2.inOut':\n      return (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);\n    case 'power3.in':\n      return (t: number) => t * t * t * t;\n    case 'power3.out':\n      return (t: number) => 1 - Math.pow(1 - t, 4);\n    case 'power3.inOut':\n      return (t: number) => (t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2);\n    case 'power4.in':\n      return (t: number) => t * t * t * t * t;\n    case 'power4.out':\n      return (t: number) => 1 - Math.pow(1 - t, 5);\n    case 'power4.inOut':\n      return (t: number) => (t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2);\n    case 'sine.in':\n      return (t: number) => 1 - Math.cos((t * Math.PI) / 2);\n    case 'sine.out':\n      return (t: number) => Math.sin((t * Math.PI) / 2);\n    case 'sine.inOut':\n      return (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;\n    case 'expo.in':\n      return (t: number) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1)));\n    case 'expo.out':\n      return (t: number) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n    case 'expo.inOut':\n      return (t: number) => {\n        if (t === 0 || t === 1) return t;\n        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;\n      };\n    case 'back.in':\n      return (t: number) => 2.7 * t * t * t - 1.7 * t * t;\n    case 'back.out':\n      return (t: number) => 1 + 2.7 * Math.pow(t - 1, 3) + 1.7 * Math.pow(t - 1, 2);\n    case 'back.inOut':\n      return (t: number) => {\n        const c1 = 1.70158;\n        const c2 = c1 * 1.525;\n        return t < 0.5\n          ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n          : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n      };\n    case 'elastic.in':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n      };\n    case 'elastic.out':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n      };\n    case 'elastic.inOut':\n      return (t: number) => {\n        const c5 = (2 * Math.PI) / 4.5;\n        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5\n          ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n          : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1;\n      };\n    case 'bounce.in':\n      return (t: number) => 1 - getEaser('bounce.out')(1 - t);\n    case 'bounce.out':\n      return (t: number) => {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (t < 1 / d1) {\n          return n1 * t * t;\n        } else if (t < 2 / d1) {\n          return n1 * (t -= 1.5 / d1) * t + 0.75;\n        } else if (t < 2.5 / d1) {\n          return n1 * (t -= 2.25 / d1) * t + 0.9375;\n        } else {\n          return n1 * (t -= 2.625 / d1) * t + 0.984375;\n        }\n      };\n    case 'bounce.inOut':\n      return (t: number) => t < 0.5\n        ? (1 - getEaser('bounce.out')(1 - 2 * t)) / 2\n        : (1 + getEaser('bounce.out')(2 * t - 1)) / 2;\n    default:\n      return (t: number) => t;\n  }\n}\n\nexport function SphereWaveform({\n  vertexCount = 400,\n  volume,\n  radius = 1,\n  pointSize = 0.04,\n  shellCount = 1,\n  seed = 1,\n  freezeTime = false,\n  advanceCount = 0,\n  advanceAmount = 1 / 60,\n  size = 1,\n  opacity = 1,\n  rotationX = 0,\n  rotationY = 0,\n  rotationZ = 0,\n  enableRandomishNoise = true,\n  randomishAmount = 1,\n  enableSineNoise = false,\n  sineAmount = 0,\n  pulseSize = 1,\n  enableSpin = false,\n  spinSpeed = 0.35,\n  randomishSpeed = 1.8,\n  enableRippleNoise = false,\n  rippleAmount = 0.0,\n  rippleSpeed = 1.5,\n  rippleScale = 3.0,\n  enableSurfaceRipple = false,\n  surfaceRippleAmount = 0.0,\n  surfaceRippleSpeed = 1.5,\n  surfaceRippleScale = 3.0,\n  spinAxisX = 0,\n  spinAxisY = 0,\n  maskEnabled = false,\n  maskRadius = 0.5,\n  maskFeather = 0.2,\n  maskInvert = false,\n  sineSpeed = 1.7,\n  sineScale = 1.0,\n  pointColor = '#ffffff',\n  glowColor = '#ffffff',\n  glowStrength = 0.0,\n  glowRadiusFactor = 0,\n  enableGradient = false,\n  gradientColor2 = '#ffffff',\n  gradientAngle = 0,\n  // softness removed\n  sizeRandomness = 0.0,\n  enableArcs = false,\n  arcMaxCount = 4,\n  arcSpawnRate = 0.25,\n  arcDuration = 4.0,\n  arcSpeed = 1.5,\n  arcSpanDeg = 60,\n  arcThickness = 0.06,\n  arcFeather = 0.04,\n  arcBrightness = 1.0,\n  arcAltitude = 0.02,\n  // blendingMode kept for API stability\n  // Modulation inputs (optional)\n  micEnvelope = 0,\n  randomishMicModAmount = 0,\n  sineMicModAmount = 0,\n  rippleMicModAmount = 0,\n  surfaceRippleMicModAmount = 0,\n  transition,\n  morph,\n}: SphereWaveformProps) {\n  const groupRef = useRef<THREE.Group | null>(null);\n  const uniformsRef = useRef<Uniforms[] | null>(null);\n  const prevNowRef = useRef<number | null>(null);\n  const timeAccRef = useRef<number>(0);\n  const lastAdvanceRef = useRef<number>(advanceCount);\n  const arcsRef = useRef<Arc[]>([]);\n\n  // Auto-transition state - only animate visual output props, not noise parameters\n  // Noise parameters (speeds, scales) create artifacts when interpolated\n  // Keep all effects enabled, animate amounts (zero = off)\n  type AnimatableKey = keyof SphereWaveformProps;\n  const animatableKeys: AnimatableKey[] = [\n    'radius','pointSize','size','opacity',\n    'rotationX','rotationY','rotationZ',\n    'randomishAmount','pulseSize', // exclude randomishSpeed\n    'sineAmount', // exclude sineSpeed, sineScale\n    'rippleAmount', // exclude rippleSpeed, rippleScale\n    'surfaceRippleAmount', // exclude surfaceRippleSpeed, surfaceRippleScale\n    'spinSpeed','spinAxisX','spinAxisY',\n    'maskRadius','maskFeather',\n    'gradientAngle','sizeRandomness',\n    'glowStrength','glowRadiusFactor',\n    'arcSpawnRate','arcDuration','arcSpeed','arcSpanDeg','arcThickness','arcFeather','arcBrightness','arcAltitude',\n    'pointColor','gradientColor2','glowColor',\n  ];\n\n  const currentValuesRef = useRef<Record<string, any> | null>(null);\n  const startValuesRef = useRef<Record<string, any> | null>(null);\n  const targetValuesRef = useRef<Record<string, any> | null>(null);\n\n  const animActiveRef = useRef<boolean>(false);\n  const animStartTimeRef = useRef<number>(0);\n  const animDurationRef = useRef<number>(0.6);\n  const animEaseRef = useRef<(t: number) => number>((t: number) => t);\n  const onStartRef = useRef<(() => void) | undefined>(undefined);\n  const onCompleteRef = useRef<(() => void) | undefined>(undefined);\n  const previousPropsRef = useRef<Record<string, any> | null>(null);\n\n  // Initialize/handle prop changes → targets and (optionally) start tween\n  useEffect(() => {\n    // Only run internal transition when explicitly enabled\n    const enabled = transition?.enabled === true;\n    const duration = (transition?.duration ?? 0.6);\n    const ease = getEaser(transition?.ease ?? 'power2.inOut');\n    onStartRef.current = transition?.onStart;\n    onCompleteRef.current = transition?.onComplete;\n    animDurationRef.current = Math.max(0, duration);\n    animEaseRef.current = ease;\n\n    // Collect current prop values (only animatable ones)\n    const currentProps = {\n      radius, pointSize, size, opacity,\n      rotationX, rotationY, rotationZ,\n      randomishAmount, pulseSize,\n      sineAmount,\n      rippleAmount,\n      surfaceRippleAmount,\n      spinSpeed, spinAxisX, spinAxisY,\n      maskRadius, maskFeather,\n      gradientAngle, sizeRandomness,\n      glowStrength, glowRadiusFactor,\n      arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n      pointColor, gradientColor2, glowColor,\n    };\n\n    if (!currentValuesRef.current) {\n      // First render - initialize with current visual state (not target props)\n      // This ensures transitions start from the actual current visual state\n      const currentVisualState = {\n        radius, pointSize, size, opacity,\n        rotationX, rotationY, rotationZ,\n        randomishAmount, pulseSize,\n        sineAmount,\n        rippleAmount,\n        surfaceRippleAmount,\n        spinSpeed, spinAxisX, spinAxisY,\n        maskRadius, maskFeather,\n        gradientAngle, sizeRandomness,\n        glowStrength, glowRadiusFactor,\n        arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n        pointColor, gradientColor2, glowColor,\n      };\n      console.log('=== INITIALIZING currentValuesRef ===');\n      console.log('currentVisualState:', currentVisualState);\n      \n      currentValuesRef.current = { ...currentVisualState };\n      startValuesRef.current = { ...currentVisualState };\n      targetValuesRef.current = { ...currentVisualState };\n      animActiveRef.current = false;\n      \n      console.log('currentValuesRef.current after init:', currentValuesRef.current);\n      console.log('=== END INIT ===');\n      return;\n    }\n\n    // Detect changes by comparing with previous props\n    let changed = false;\n    if (previousPropsRef.current) {\n      for (const key of animatableKeys) {\n        const previousValue = previousPropsRef.current[key];\n        const newValue = (currentProps as any)[key];\n        \n        if (typeof previousValue === 'number' && typeof newValue === 'number') {\n          if (Math.abs(previousValue - newValue) > 1e-9) {\n            changed = true;\n            break;\n          }\n        } else if (typeof previousValue === 'string' && typeof newValue === 'string') {\n          if (previousValue !== newValue) {\n            changed = true;\n            break;\n          }\n        }\n      }\n    } else {\n      // First time detecting changes - always start transition\n      changed = true;\n    }\n\n    if (!changed) {\n      // Update previous props but don't start animation\n      previousPropsRef.current = { ...currentProps };\n      return;\n    }\n\n    if (!enabled || animDurationRef.current === 0) {\n      // Snap to target values\n      console.log('=== SNAPPING VALUES (NO TRANSITION) ===');\n      console.log('enabled:', enabled, 'duration:', animDurationRef.current);\n      console.log('transition:', transition);\n      console.log('currentValuesRef.current BEFORE snap:', currentValuesRef.current);\n      console.log('currentProps (target):', currentProps);\n      \n      currentValuesRef.current = { ...currentProps };\n      targetValuesRef.current = { ...currentProps };\n      previousPropsRef.current = { ...currentProps };\n      animActiveRef.current = false;\n      \n      console.log('currentValuesRef.current AFTER snap:', currentValuesRef.current);\n      console.log('=== END SNAP ===');\n      return;\n    }\n\n    // Start animation from current animated values → new target\n    console.log('=== STARTING TRANSITION ===');\n    console.log('currentValuesRef.current BEFORE transition start:', currentValuesRef.current);\n    console.log('currentProps (target):', currentProps);\n    \n    startValuesRef.current = { ...currentValuesRef.current };\n    targetValuesRef.current = { ...currentProps };\n    previousPropsRef.current = { ...currentProps };\n    animStartTimeRef.current = performance.now();\n    animActiveRef.current = true;\n    \n    console.log('startValuesRef.current:', startValuesRef.current);\n    console.log('targetValuesRef.current:', targetValuesRef.current);\n    console.log('=== END TRANSITION START ===');\n    \n    try { onStartRef.current && onStartRef.current(); } catch {}\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    transition?.enabled, transition?.duration, transition?.ease,\n    radius, pointSize, size, opacity,\n    rotationX, rotationY, rotationZ,\n    randomishAmount, pulseSize,\n    sineAmount,\n    rippleAmount,\n    surfaceRippleAmount,\n    spinSpeed, spinAxisX, spinAxisY,\n    maskRadius, maskFeather,\n    gradientAngle, sizeRandomness,\n    glowStrength, glowRadiusFactor,\n    arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n    pointColor, gradientColor2, glowColor,\n  ]);\n\n  const { positions, seeds } = useMemo(\n    () => generateFibonacciSpherePoints(vertexCount, radius, seed),\n    [vertexCount, radius, seed]\n  );\n\n  // Lazily create uniforms per shell and keep array length in sync without\n  // replacing existing objects (to avoid freezing on shell changes).\n  if (uniformsRef.current === null) {\n    uniformsRef.current = []\n  }\n  {\n    const count = Math.max(1, Math.floor(shellCount))\n    const arr = uniformsRef.current\n    // Grow\n    for (let i = arr.length; i < count; i++) {\n      arr.push({\n        uTime: { value: 0 },\n        uVolume: { value: 0 },\n        uRadius: { value: radius * (i === 0 ? 1 : 1 + i * 0.2) },\n        uRadius2: { value: radius * (i === 0 ? 1 : 1 + i * 0.2) },\n        uPointSize: { value: pointSize },\n        uPointSize2: { value: pointSize },\n        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },\n        uViewportWidth: { value: window.innerWidth },\n        uViewportHeight: { value: window.innerHeight },\n        uFov: { value: (60 * Math.PI) / 180 },\n        uShellPhase: { value: 0 },\n        uSizeRandomness: { value: sizeRandomness },\n        uEnableRandomish: { value: enableRandomishNoise ? 1 : 0 },\n        uRandomishAmount: { value: randomishAmount },\n        uRandomishAmount2: { value: randomishAmount },\n        uEnableSine: { value: enableSineNoise ? 1 : 0 },\n        uSineAmount: { value: sineAmount },\n        uSineAmount2: { value: sineAmount },\n        uRandomishSpeed: { value: randomishSpeed },\n        uRandomishSpeed2: { value: randomishSpeed },\n        uPulseSize: { value: pulseSize },\n        uPulseSize2: { value: pulseSize },\n        uOpacity: { value: opacity },\n        // Size randomness\n        \n        // Halo expansion\n        uGlowRadiusFactor: { value: glowRadiusFactor },\n        uExpandHalo: { value: 1 },\n        uGlowRadiusFactor2: { value: glowRadiusFactor },\n        // uGlowSoftness removed\n        // Ripple uniforms\n        uEnableRipple: { value: enableRippleNoise ? 1 : 0 },\n        uRippleAmount: { value: rippleAmount },\n        uRippleAmount2: { value: rippleAmount },\n        uRippleSpeed: { value: rippleSpeed },\n        uRippleSpeed2: { value: rippleSpeed },\n        uRippleScale: { value: rippleScale },\n        uRippleScale2: { value: rippleScale },\n        // Surface ripple (tangent displacement)\n        uEnableSurfaceRipple: { value: enableSurfaceRipple ? 1 : 0 },\n        uSurfaceRippleAmount: { value: surfaceRippleAmount },\n        uSurfaceRippleAmount2: { value: surfaceRippleAmount },\n        uSurfaceRippleSpeed: { value: surfaceRippleSpeed },\n        uSurfaceRippleSpeed2: { value: surfaceRippleSpeed },\n        uSurfaceRippleScale: { value: surfaceRippleScale },\n        uSurfaceRippleScale2: { value: surfaceRippleScale },\n        uSurfaceCenter: { value: new THREE.Vector3(0, 0, 1) },\n        // New toggle-based uniforms\n        uEnableSpin: { value: enableSpin ? 1 : 0 },\n        uSpinSpeed: { value: spinSpeed },\n        uSpinSpeed2: { value: spinSpeed },\n        // Spin axis uniforms\n        uSpinAxisX: { value: spinAxisX },\n        uSpinAxisY: { value: spinAxisY },\n        uSpinAxisX2: { value: spinAxisX },\n        uSpinAxisY2: { value: spinAxisY },\n        // Screen-space mask uniforms\n        uMaskEnabled: { value: maskEnabled ? 1 : 0 },\n        uMaskRadiusPx: { value: 0 },\n        uMaskFeatherPx: { value: 0 },\n        uMaskInvert: { value: maskInvert ? 1 : 0 },\n        uMaskCenterNdc: { value: new THREE.Vector2(0, 0) },\n        // Sine noise uniforms\n        uSineSpeed: { value: sineSpeed },\n        uSineScale: { value: sineScale },\n        uSineSpeed2: { value: sineSpeed },\n        uSineScale2: { value: sineScale },\n        // Appearance\n        uColor: { value: new THREE.Color(pointColor) },\n        uColor2: { value: new THREE.Color(gradientColor2) },\n        uEnableGradient: { value: enableGradient ? 1 : 0 },\n        uGradientAngle: { value: 0 },\n        uGlowColor: { value: new THREE.Color(glowColor) },\n        uGlowStrength: { value: glowStrength },\n        uMorphProgress: { value: 0 },\n        \n        uArcsActive: { value: 0 },\n        uArcCenters: { value: new Float32Array(8 * 3) },\n        uArcTangents: { value: new Float32Array(8 * 3) },\n        uArcT0: { value: new Float32Array(8) },\n        uArcDur: { value: new Float32Array(8) },\n        uArcSpeed: { value: new Float32Array(8) },\n        uArcSpan: { value: new Float32Array(8) },\n        uArcThick: { value: new Float32Array(8) },\n        uArcFeather: { value: new Float32Array(8) },\n        uArcBright: { value: new Float32Array(8) },\n        uArcAltitude: { value: arcAltitude },\n      })\n    }\n    // Shrink\n    if (arr.length > count) {\n      arr.length = count\n    }\n  }\n\n  useFrame((stateFrame) => {\n    const uniformsArray = uniformsRef.current!;\n    const now = stateFrame.clock.getElapsedTime();\n    if (prevNowRef.current === null) {\n      prevNowRef.current = now;\n      timeAccRef.current = now;\n      lastAdvanceRef.current = advanceCount;\n    }\n    const dt = Math.max(0, now - prevNowRef.current);\n    prevNowRef.current = now;\n\n    if (freezeTime) {\n      if (advanceCount !== lastAdvanceRef.current) {\n        const diff = advanceCount - lastAdvanceRef.current;\n        timeAccRef.current += diff * advanceAmount;\n        lastAdvanceRef.current = advanceCount;\n      }\n    } else {\n      timeAccRef.current += dt;\n      lastAdvanceRef.current = advanceCount;\n    }\n\n    // Stateful random arc spawner\n    const arcs = arcsRef.current;\n    // Cull expired\n    for (let i = arcs.length - 1; i >= 0; i--) {\n      if (timeAccRef.current - arcs[i].t0 > arcs[i].duration) {\n        arcs.splice(i, 1);\n      }\n    }\n    const maxArcs = Math.min(8, Math.max(0, Math.floor(arcMaxCount)));\n    if (enableArcs && arcSpawnRate > 0 && arcs.length < maxArcs && dt > 0) {\n      let expected = arcSpawnRate * dt;\n      let spawns = Math.floor(expected);\n      const rem = expected - spawns;\n      if (Math.random() < rem) spawns += 1;\n      for (let s = 0; s < spawns && arcs.length < maxArcs; s++) {\n        // Random center on unit sphere\n        const u = Math.random();\n        const v = Math.random();\n        const theta = 2 * Math.PI * u;\n        const z = 2 * v - 1;\n        const r = Math.sqrt(Math.max(0, 1 - z * z));\n        const cx = r * Math.cos(theta);\n        const cy = r * Math.sin(theta);\n        const cz = z;\n        const center = new THREE.Vector3(cx, cy, cz).normalize();\n        // Random direction orthogonal to center\n        const rand = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\n        let tangent = new THREE.Vector3().crossVectors(center, rand);\n        if (tangent.lengthSq() < 1e-6) {\n          tangent = new THREE.Vector3().crossVectors(center, new THREE.Vector3(1, 0, 0));\n        }\n        tangent.normalize();\n        arcs.push({\n          center,\n          tangent,\n          t0: timeAccRef.current,\n          duration: arcDuration,\n          speed: arcSpeed,\n          span: (Math.max(0, arcSpanDeg) * Math.PI) / 180,\n          thickness: Math.max(0, arcThickness),\n          feather: Math.max(0.0001, arcFeather),\n          brightness: Math.max(0, arcBrightness),\n        });\n      }\n    }\n\n    // Pack arc uniforms\n    const centers = new Float32Array(8 * 3);\n    const tangents = new Float32Array(8 * 3);\n    const t0 = new Float32Array(8);\n    const dur = new Float32Array(8);\n    const spd = new Float32Array(8);\n    const span = new Float32Array(8);\n    const thick = new Float32Array(8);\n    const feath = new Float32Array(8);\n    const bright = new Float32Array(8);\n    const arcsActive = Math.min(arcs.length, 8);\n    for (let i = 0; i < arcsActive; i++) {\n      const a = arcs[i];\n      const idx3 = i * 3;\n      centers[idx3 + 0] = a.center.x; centers[idx3 + 1] = a.center.y; centers[idx3 + 2] = a.center.z;\n      tangents[idx3 + 0] = a.tangent.x; tangents[idx3 + 1] = a.tangent.y; tangents[idx3 + 2] = a.tangent.z;\n      t0[i] = a.t0;\n      dur[i] = a.duration;\n      spd[i] = a.speed;\n      span[i] = a.span;\n      thick[i] = a.thickness;\n      feath[i] = a.feather;\n      bright[i] = a.brightness;\n    }\n\n    // Advance auto-transition using performance.now() like the original runner\n    if (animActiveRef.current && currentValuesRef.current && startValuesRef.current && targetValuesRef.current) {\n      const now = performance.now();\n      const elapsed = now - animStartTimeRef.current;\n      const durationMs = animDurationRef.current * 1000;\n      const t = Math.min(1, durationMs === 0 ? 1 : elapsed / durationMs);\n      const te = animEaseRef.current(t);\n      \n      // Interpolate all animatable values\n      for (const key of animatableKeys) {\n        const start = startValuesRef.current[key];\n        const target = targetValuesRef.current[key];\n        \n        if (typeof start === 'number' && typeof target === 'number') {\n          currentValuesRef.current[key] = start + (target - start) * te;\n        } else if (typeof start === 'string' && typeof target === 'string') {\n          // Handle color interpolation\n          try {\n            const startColor = new THREE.Color(start);\n            const targetColor = new THREE.Color(target);\n            const lerpedColor = startColor.clone().lerp(targetColor, te);\n            currentValuesRef.current[key] = `#${lerpedColor.getHexString()}`;\n          } catch {\n            // Invalid color, snap to target\n            currentValuesRef.current[key] = target;\n          }\n        }\n      }\n      \n      if (t >= 1) {\n        animActiveRef.current = false;\n        try { onCompleteRef.current && onCompleteRef.current(); } catch {}\n      }\n    }\n\n    // Use animated values only while an internal transition is active; otherwise use live props\n    const anim = animActiveRef.current ? currentValuesRef.current : null;\n    const radiusV = anim?.radius ?? radius;\n    const pointSizeV = anim?.pointSize ?? pointSize;\n    const sizeV = anim?.size ?? size;\n    const opacityV = anim?.opacity ?? opacity;\n    const rotationXV = anim?.rotationX ?? rotationX;\n    const rotationYV = anim?.rotationY ?? rotationY;\n    const rotationZV = anim?.rotationZ ?? rotationZ;\n    const randomishAmountV = anim?.randomishAmount ?? randomishAmount;\n    const randomishSpeedV = randomishSpeed; // Always use prop value (not animated)\n    const pulseSizeV = anim?.pulseSize ?? pulseSize;\n    const sineAmountV = anim?.sineAmount ?? sineAmount;\n    const sineSpeedV = sineSpeed; // Always use prop value (not animated)\n    const sineScaleV = sineScale; // Always use prop value (not animated)\n    const rippleAmountV = anim?.rippleAmount ?? rippleAmount;\n    const rippleSpeedV = rippleSpeed; // Always use prop value (not animated)\n    const rippleScaleV = rippleScale; // Always use prop value (not animated)\n    const surfaceRippleAmountV = anim?.surfaceRippleAmount ?? surfaceRippleAmount;\n    const surfaceRippleSpeedV = surfaceRippleSpeed; // Always use prop value (not animated)\n    const surfaceRippleScaleV = surfaceRippleScale; // Always use prop value (not animated)\n    const spinSpeedV = anim?.spinSpeed ?? spinSpeed;\n    const spinAxisXV = anim?.spinAxisX ?? spinAxisX;\n    const spinAxisYV = anim?.spinAxisY ?? spinAxisY;\n    // Masks should respond instantly to UI; use raw props\n    const maskRadiusV = maskRadius;\n    const maskFeatherV = maskFeather;\n    const gradientAngleV = anim?.gradientAngle ?? gradientAngle;\n    const sizeRandomnessV = anim?.sizeRandomness ?? sizeRandomness;\n    const glowStrengthV = anim?.glowStrength ?? glowStrength;\n    const glowRadiusFactorV = anim?.glowRadiusFactor ?? glowRadiusFactor;\n    const arcAltitudeV = anim?.arcAltitude ?? arcAltitude;\n    \n    // Color values\n    const pointColorV = anim?.pointColor ?? pointColor;\n    const gradientColor2V = anim?.gradientColor2 ?? gradientColor2;\n    const glowColorV = anim?.glowColor ?? glowColor;\n\n    // Update group transform directly to avoid re-renders\n    if (groupRef.current) {\n      groupRef.current.scale.set(sizeV, sizeV, sizeV);\n      groupRef.current.rotation.set(\n        THREE.MathUtils.degToRad(rotationXV),\n        THREE.MathUtils.degToRad(rotationYV),\n        THREE.MathUtils.degToRad(rotationZV)\n      );\n    }\n\n    // Morph context: B-lane target and progress\n    const mEnabled = Boolean(morph?.enabled);\n    const mProgress = THREE.MathUtils.clamp(morph?.progress ?? 0, 0, 1);\n    const toCfg = (mEnabled && morph?.to) ? morph.to : undefined;\n\n    for (let i = 0; i < uniformsArray.length; i++) {\n      const u = uniformsArray[i];\n      u.uTime.value = timeAccRef.current;\n      u.uRadius.value = radiusV * (1 + i * 0.2);\n      const radiusB = (toCfg?.radius as number | undefined) ?? radius;\n      u.uRadius2.value = radiusB * (1 + i * 0.2);\n      u.uPointSize.value = pointSizeV;\n      u.uPointSize2.value = (toCfg?.pointSize as number | undefined) ?? pointSize;\n      u.uViewportWidth.value = stateFrame.size.width;\n      u.uViewportHeight.value = stateFrame.size.height;\n      const cam = stateFrame.camera as THREE.PerspectiveCamera;\n      if (cam && typeof (cam as any).fov === 'number') {\n        u.uFov.value = (cam.fov * Math.PI) / 180;\n      }\n      u.uVolume.value = THREE.MathUtils.clamp(volume, 0, 1);\n      u.uEnableRandomish.value = 1; // Always enabled\n      const micEnv = THREE.MathUtils.clamp(micEnvelope, 0, 1);\n      const randomishAmountFinal = THREE.MathUtils.clamp(\n        (randomishAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(randomishMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uRandomishAmount.value = randomishAmountFinal;\n      const randomishAmountB = THREE.MathUtils.clamp(\n        (((toCfg?.randomishAmount as number | undefined) ?? randomishAmount) || 0) + micEnv * THREE.MathUtils.clamp(randomishMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uRandomishAmount2.value = randomishAmountB;\n      u.uEnableSine.value = 1; // Always enabled\n      const sineAmountFinal = THREE.MathUtils.clamp(\n        (sineAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(sineMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uSineAmount.value = sineAmountFinal;\n      const sineAmountB = THREE.MathUtils.clamp(\n        (((toCfg?.sineAmount as number | undefined) ?? sineAmount) || 0) + micEnv * THREE.MathUtils.clamp(sineMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uSineAmount2.value = sineAmountB;\n      u.uRandomishSpeed.value = randomishSpeedV;\n      u.uRandomishSpeed2.value = (toCfg?.randomishSpeed as number | undefined) ?? randomishSpeed;\n      u.uPulseSize.value = THREE.MathUtils.clamp(pulseSizeV, 0, 1);\n      u.uPulseSize2.value = THREE.MathUtils.clamp(((toCfg?.pulseSize as number | undefined) ?? pulseSize), 0, 1);\n      u.uOpacity.value = THREE.MathUtils.clamp(opacityV, 0, 1);\n      u.uSizeRandomness.value = THREE.MathUtils.clamp(sizeRandomnessV, 0, 1);\n      // Ripple\n      u.uEnableRipple.value = 1; // Always enabled\n      u.uRippleAmount.value = THREE.MathUtils.clamp(\n        (rippleAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(rippleMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uRippleSpeed.value = rippleSpeedV;\n      u.uRippleScale.value = rippleScaleV;\n      u.uRippleAmount2.value = THREE.MathUtils.clamp(\n        (((toCfg?.rippleAmount as number | undefined) ?? rippleAmount) || 0) + micEnv * THREE.MathUtils.clamp(rippleMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uRippleSpeed2.value = (toCfg?.rippleSpeed as number | undefined) ?? rippleSpeed;\n      u.uRippleScale2.value = (toCfg?.rippleScale as number | undefined) ?? rippleScale;\n      // Surface ripple\n      u.uEnableSurfaceRipple.value = 1; // Always enabled\n      u.uSurfaceRippleAmount.value = THREE.MathUtils.clamp(\n        (surfaceRippleAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(surfaceRippleMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uSurfaceRippleSpeed.value = surfaceRippleSpeedV;\n      u.uSurfaceRippleScale.value = surfaceRippleScaleV;\n      u.uSurfaceRippleAmount2.value = THREE.MathUtils.clamp(\n        (((toCfg?.surfaceRippleAmount as number | undefined) ?? surfaceRippleAmount) || 0) + micEnv * THREE.MathUtils.clamp(surfaceRippleMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uSurfaceRippleSpeed2.value = (toCfg?.surfaceRippleSpeed as number | undefined) ?? surfaceRippleSpeed;\n      u.uSurfaceRippleScale2.value = (toCfg?.surfaceRippleScale as number | undefined) ?? surfaceRippleScale;\n      u.uEnableSpin.value = 1; // Always enabled\n      u.uSpinSpeed.value = spinSpeedV;\n      u.uSpinSpeed2.value = (toCfg?.spinSpeed as number | undefined) ?? spinSpeed;\n      u.uSpinAxisX.value = spinAxisXV;\n      u.uSpinAxisY.value = spinAxisYV;\n      u.uSpinAxisX2.value = (toCfg?.spinAxisX as number | undefined) ?? spinAxisX;\n      u.uSpinAxisY2.value = (toCfg?.spinAxisY as number | undefined) ?? spinAxisY;\n      // Mask that follows sphere center in screen space; blend A/B by morph progress\n      const maskRadiusB = THREE.MathUtils.clamp(((toCfg?.maskRadius as number | undefined) ?? maskRadius), 0, 1);\n      const maskFeatherB = THREE.MathUtils.clamp(((toCfg?.maskFeather as number | undefined) ?? maskFeather), 0, 1);\n      const maskRadiusMix = mEnabled ? (THREE.MathUtils.clamp(maskRadiusV, 0, 1) + (maskRadiusB - THREE.MathUtils.clamp(maskRadiusV, 0, 1)) * mProgress) : THREE.MathUtils.clamp(maskRadiusV, 0, 1);\n      const maskFeatherMix = mEnabled ? (THREE.MathUtils.clamp(maskFeatherV, 0, 1) + (maskFeatherB - THREE.MathUtils.clamp(maskFeatherV, 0, 1)) * mProgress) : THREE.MathUtils.clamp(maskFeatherV, 0, 1);\n      u.uMaskEnabled.value = (maskRadiusMix > 0 || maskFeatherMix > 0) ? 1 : 0;\n      u.uMaskInvert.value = maskInvert ? 1 : 0;\n      // Compute mask center from group's world position to ensure correct alignment\n      const worldCenter = new THREE.Vector3();\n      if (groupRef.current) {\n        groupRef.current.getWorldPosition(worldCenter);\n      } else {\n        worldCenter.set(0, 0, 0);\n      }\n      const centerNdc = worldCenter.clone().project(cam);\n      u.uMaskCenterNdc.value.set(centerNdc.x, centerNdc.y);\n      const minHalf = Math.min(stateFrame.size.width, stateFrame.size.height) * 0.5;\n      // Map normalized maskRadius to pixels, adjusted by zoom (keeps scale roughly stable)\n      u.uMaskRadiusPx.value = maskRadiusMix * minHalf * (1.0 / Math.max(1e-3, cam.zoom));\n      u.uMaskFeatherPx.value = maskFeatherMix * minHalf * (1.0 / Math.max(1e-3, cam.zoom));\n      // Sine noise\n      u.uSineSpeed.value = sineSpeedV;\n      u.uSineScale.value = sineScaleV;\n      u.uSineSpeed2.value = (toCfg?.sineSpeed as number | undefined) ?? sineSpeed;\n      u.uSineScale2.value = (toCfg?.sineScale as number | undefined) ?? sineScale;\n      // Color\n      // CPU-blend colors and gradient angle by morph progress\n      {\n        const colA = new THREE.Color(pointColorV);\n        const colB = new THREE.Color(((toCfg?.pointColor as string | undefined) ?? pointColor) || pointColor);\n        const colMix = colA.clone().lerp(colB, mProgress);\n        u.uColor.value.copy(colMix);\n        const gradA = new THREE.Color(gradientColor2V);\n        const gradB = new THREE.Color(((toCfg?.gradientColor2 as string | undefined) ?? gradientColor2) || gradientColor2);\n        const gradMix = gradA.clone().lerp(gradB, mProgress);\n        u.uColor2.value.copy(gradMix);\n        u.uEnableGradient.value = 1; // Always enabled\n        const angA = gradientAngleV;\n        const angB = (toCfg?.gradientAngle as number | undefined) ?? gradientAngle;\n        const angMix = angA + (angB - angA) * mProgress;\n        u.uGradientAngle.value = THREE.MathUtils.degToRad(angMix);\n      }\n      u.uGlowColor.value.set(glowColorV);\n      u.uGlowStrength.value = THREE.MathUtils.clamp(glowStrengthV, 0, 3);\n      u.uGlowRadiusFactor.value = Math.max(0, glowRadiusFactorV);\n      u.uGlowRadiusFactor2.value = Math.max(0, ((toCfg?.glowRadiusFactor as number | undefined) ?? glowRadiusFactor));\n      // Morph progress uniform\n      u.uMorphProgress.value = mEnabled ? mProgress : 0;\n      // Per-shell phase: deterministic from base seed and shell index\n      const phaseBase = Math.sin((seed + i * 17.23) * 12.9898) * 43758.5453;\n      const jitter = 1.0; // read directly from config in App if needed; default 1 here\n      u.uShellPhase.value = (phaseBase - Math.floor(phaseBase)) * jitter;\n      // Arcs\n      u.uArcsActive.value = arcsActive; // Always enabled\n      u.uArcCenters.value.set(centers);\n      u.uArcTangents.value.set(tangents);\n      u.uArcT0.value.set(t0);\n      u.uArcDur.value.set(dur);\n      u.uArcSpeed.value.set(spd);\n      u.uArcSpan.value.set(span);\n      u.uArcThick.value.set(thick);\n      u.uArcFeather.value.set(feath);\n      u.uArcBright.value.set(bright);\n      u.uArcAltitude.value = arcAltitudeV;\n    }\n  });\n\n  return (\n    <group ref={groupRef} scale={[size, size, size]} rotation={[THREE.MathUtils.degToRad(rotationX), THREE.MathUtils.degToRad(rotationY), THREE.MathUtils.degToRad(rotationZ)]}>\n      {uniformsRef.current!.map((u, i) => (\n        <group key={`shell-${i}`} renderOrder={i}>\n        {/* Single pass again: core only; bloom will provide glow */}\n        <points>\n          <bufferGeometry key={`${vertexCount}-${radius}-${seed}-${i}`}>\n            <bufferAttribute attach=\"attributes-position\" args={[positions, 3]} />\n            <bufferAttribute attach=\"attributes-aSeed\" args={[seeds, 1]} />\n          </bufferGeometry>\n          <shaderMaterial\n            vertexShader={vertexShader}\n            fragmentShader={fragmentShader}\n            uniforms={u as unknown as { [key: string]: THREE.IUniform }}\n            transparent\n            depthWrite={false}\n            depthTest\n            alphaTest={0.001}\n            premultipliedAlpha={false}\n            blending={THREE.NormalBlending}\n          />\n        </points>\n        </group>\n      ))}\n    </group>\n  );\n}\n\nexport default SphereWaveform;\n","export type AnimEase =\n  | 'linear'\n  | 'power1.in' | 'power1.out' | 'power1.inOut'\n  | 'power2.in' | 'power2.out' | 'power2.inOut'\n  | 'power3.in' | 'power3.out' | 'power3.inOut'\n  | 'power4.in' | 'power4.out' | 'power4.inOut'\n  | 'sine.in' | 'sine.out' | 'sine.inOut'\n  | 'expo.in' | 'expo.out' | 'expo.inOut'\n  | 'back.in' | 'back.out' | 'back.inOut'\n  | 'elastic.in' | 'elastic.out' | 'elastic.inOut'\n  | 'bounce.in' | 'bounce.out' | 'bounce.inOut';\n\nexport function getEaser(name: AnimEase | undefined): (t: number) => number {\n  switch (name) {\n    case 'linear':\n      return (t: number) => t;\n    case 'power1.in':\n      return (t: number) => t * t;\n    case 'power1.out':\n      return (t: number) => 1 - Math.pow(1 - t, 2);\n    case 'power1.inOut':\n      return (t: number) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);\n    case 'power2.in':\n      return (t: number) => t * t * t;\n    case 'power2.out':\n      return (t: number) => 1 - Math.pow(1 - t, 3);\n    case 'power2.inOut':\n      return (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);\n    case 'power3.in':\n      return (t: number) => t * t * t * t;\n    case 'power3.out':\n      return (t: number) => 1 - Math.pow(1 - t, 4);\n    case 'power3.inOut':\n      return (t: number) => (t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2);\n    case 'power4.in':\n      return (t: number) => t * t * t * t * t;\n    case 'power4.out':\n      return (t: number) => 1 - Math.pow(1 - t, 5);\n    case 'power4.inOut':\n      return (t: number) => (t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2);\n    case 'sine.in':\n      return (t: number) => 1 - Math.cos((t * Math.PI) / 2);\n    case 'sine.out':\n      return (t: number) => Math.sin((t * Math.PI) / 2);\n    case 'sine.inOut':\n      return (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;\n    case 'expo.in':\n      return (t: number) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1)));\n    case 'expo.out':\n      return (t: number) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n    case 'expo.inOut':\n      return (t: number) => {\n        if (t === 0 || t === 1) return t;\n        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;\n      };\n    case 'back.in':\n      return (t: number) => 2.7 * t * t * t - 1.7 * t * t;\n    case 'back.out':\n      return (t: number) => 1 + 2.7 * Math.pow(t - 1, 3) + 1.7 * Math.pow(t - 1, 2);\n    case 'back.inOut':\n      return (t: number) => {\n        const c1 = 1.70158;\n        const c2 = c1 * 1.525;\n        return t < 0.5\n          ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n          : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n      };\n    case 'elastic.in':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n      };\n    case 'elastic.out':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n      };\n    case 'elastic.inOut':\n      return (t: number) => {\n        const c5 = (2 * Math.PI) / 4.5;\n        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5\n          ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n          : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1;\n      };\n    case 'bounce.in':\n      return (t: number) => 1 - getEaser('bounce.out')(1 - t);\n    case 'bounce.out':\n      return (t: number) => {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (t < 1 / d1) {\n          return n1 * t * t;\n        } else if (t < 2 / d1) {\n          return n1 * (t -= 1.5 / d1) * t + 0.75;\n        } else if (t < 2.5 / d1) {\n          return n1 * (t -= 2.25 / d1) * t + 0.9375;\n        } else {\n          return n1 * (t -= 2.625 / d1) * t + 0.984375;\n        }\n      };\n    case 'bounce.inOut':\n      return (t: number) => t < 0.5\n        ? (1 - getEaser('bounce.out')(1 - 2 * t)) / 2\n        : (1 + getEaser('bounce.out')(2 * t - 1)) / 2;\n    default:\n      return (t: number) => t;\n  }\n}\n\n\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { SphereWaveformProps } from '../components/SphereWaveform';\nimport { getEaser, type AnimEase } from './easing';\n\nexport type WaveformConfig = Omit<SphereWaveformProps, 'transition' | 'morph'>;\n\nexport type AnimSpec = {\n  to: Partial<WaveformConfig>;\n  duration: number; // seconds\n  ease?: AnimEase;\n};\n\nexport function interpolateConfig(\n  from: WaveformConfig,\n  to: Partial<WaveformConfig>,\n  t: number\n): WaveformConfig {\n  const out: any = { ...from };\n  const mixNum = (a: number, b: number) => a + (b - a) * t;\n  const maybe = <T,>(v: T | undefined, fallback: T): T => (v === undefined ? fallback : v);\n\n  const numericKeys: Array<keyof WaveformConfig> = [\n    'vertexCount','volume','radius','pointSize','shellCount','seed','size','opacity',\n    'rotationX','rotationY','rotationZ',\n    'randomishAmount','randomishSpeed','pulseSize',\n    'rippleAmount','rippleSpeed','rippleScale',\n    'surfaceRippleAmount','surfaceRippleSpeed','surfaceRippleScale',\n    'spinSpeed','spinAxisX','spinAxisY',\n    'maskRadius','maskFeather',\n    'sineAmount','sineSpeed','sineScale',\n    'glowStrength','glowRadiusFactor','sizeRandomness',\n    'arcMaxCount','arcSpawnRate','arcDuration','arcSpeed','arcSpanDeg','arcThickness','arcFeather','arcBrightness','arcAltitude',\n    'advanceCount','advanceAmount',\n  ];\n\n  for (const key of numericKeys) {\n    const a = from[key] as unknown as number;\n    const b = maybe(to[key] as unknown as number | undefined, a);\n    if (typeof a === 'number' && typeof b === 'number') out[key] = mixNum(a, b);\n  }\n\n  const colorKeys: Array<keyof WaveformConfig> = ['pointColor','glowColor','gradientColor2'];\n  for (const key of colorKeys) {\n    const a = from[key] as unknown as string | undefined;\n    const b = (to[key] as unknown as string | undefined) ?? a;\n    if (typeof a === 'string' && typeof b === 'string') {\n      try {\n        // Keep output as hex string for UI friendliness\n        const ca = new (window as any).THREE.Color(a);\n        const cb = new (window as any).THREE.Color(b);\n        const cm = ca.clone().lerp(cb, t);\n        out[key] = `#${cm.getHexString()}`;\n      } catch {\n        out[key] = t < 0.5 ? a : b;\n      }\n    }\n  }\n\n  // Booleans are always-on; keep existing values (zero=off policy)\n  out.enableRandomishNoise = true;\n  out.enableSineNoise = true;\n  out.enableRippleNoise = true;\n  out.enableSurfaceRipple = true;\n  out.enableSpin = true;\n  out.enableGradient = true;\n  out.enableArcs = true;\n  out.maskEnabled = true;\n\n  // Non-animative flags\n  out.freezeTime = from.freezeTime;\n  out.advanceCount = from.advanceCount;\n  out.advanceAmount = from.advanceAmount;\n  out.maskInvert = from.maskInvert;\n  out.blendingMode = from.blendingMode;\n\n  return out as WaveformConfig;\n}\n\nexport function useMorphAnimator(opts?: {\n  ease?: AnimEase;\n  onStart?: () => void;\n  onUpdate?: (progress: number) => void;\n  onComplete?: (final: WaveformConfig) => void;\n}) {\n  const easeFnRef = useRef<(t: number) => number>(getEaser(opts?.ease ?? 'power2.inOut'));\n  const rafRef = useRef<number | null>(null);\n  const startRef = useRef<number>(0);\n  const durRef = useRef<number>(0);\n  const fromRef = useRef<WaveformConfig | null>(null);\n  const toRef = useRef<Partial<WaveformConfig> | null>(null);\n\n  const [enabled, setEnabled] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [toState, setToState] = useState<Partial<WaveformConfig> | undefined>(undefined);\n\n  useEffect(() => {\n    easeFnRef.current = getEaser(opts?.ease ?? 'power2.inOut');\n  }, [opts?.ease]);\n\n  const cancel = useCallback(() => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    rafRef.current = null;\n    setEnabled(false);\n  }, []);\n\n  const play = useCallback((anim: AnimSpec, from: WaveformConfig) => {\n    cancel();\n    fromRef.current = { ...from };\n    toRef.current = { ...anim.to };\n    durRef.current = Math.max(0, anim.duration) * 1000;\n    easeFnRef.current = getEaser(anim.ease ?? opts?.ease ?? 'power2.inOut');\n\n    setToState(anim.to);\n    setEnabled(true);\n    setProgress(0);\n    opts?.onStart?.();\n\n    startRef.current = performance.now();\n    const tick = () => {\n      const now = performance.now();\n      const t = durRef.current === 0 ? 1 : Math.min(1, (now - startRef.current) / durRef.current);\n      const te = easeFnRef.current(t);\n      setProgress(te);\n      opts?.onUpdate?.(te);\n      if (t < 1) {\n        rafRef.current = requestAnimationFrame(tick);\n      } else {\n        rafRef.current = null;\n        setEnabled(false);\n        const final = interpolateConfig(fromRef.current!, toRef.current!, 1);\n        opts?.onComplete?.(final);\n      }\n    };\n    rafRef.current = requestAnimationFrame(tick);\n  }, [cancel, opts]);\n\n  const morph = enabled\n    ? { enabled: true, progress, to: toState }\n    : { enabled: false, progress: 0 };\n\n  return { morph, play, cancel, playing: enabled, progress } as const;\n}\n\nexport class MorphController {\n  private easeFn: (t: number) => number;\n  private raf: number | null = null;\n  private start = 0;\n  private durMs = 0;\n  private from!: WaveformConfig;\n  private to!: Partial<WaveformConfig>;\n\n  constructor(ease: AnimEase = 'power2.inOut') {\n    this.easeFn = getEaser(ease);\n  }\n\n  cancel() {\n    if (this.raf) cancelAnimationFrame(this.raf);\n    this.raf = null;\n  }\n\n  async play(anim: AnimSpec, from: WaveformConfig, onProgress: (p: number, to: Partial<WaveformConfig>) => void): Promise<WaveformConfig> {\n    this.cancel();\n    this.from = { ...from };\n    this.to = { ...anim.to };\n    this.durMs = Math.max(0, anim.duration) * 1000;\n    this.easeFn = getEaser(anim.ease ?? 'power2.inOut');\n    this.start = performance.now();\n\n    return new Promise<WaveformConfig>((resolve) => {\n      const tick = () => {\n        const now = performance.now();\n        const t = this.durMs === 0 ? 1 : Math.min(1, (now - this.start) / this.durMs);\n        const te = this.easeFn(t);\n        onProgress(te, this.to);\n        if (t < 1) {\n          this.raf = requestAnimationFrame(tick);\n        } else {\n          this.raf = null;\n          resolve(interpolateConfig(this.from, this.to, 1));\n        }\n      };\n      this.raf = requestAnimationFrame(tick);\n    });\n  }\n}\n\n\n"],"names":["REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","jsxProd","type","config","maybeKey","key","propName","reactJsxRuntime_production","getComponentNameFromType","REACT_CLIENT_REFERENCE","REACT_PROFILER_TYPE","REACT_STRICT_MODE_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_ACTIVITY_TYPE","REACT_PORTAL_TYPE","REACT_CONTEXT_TYPE","REACT_CONSUMER_TYPE","REACT_FORWARD_REF_TYPE","innerType","REACT_MEMO_TYPE","REACT_LAZY_TYPE","testStringCoercion","value","checkKeyStringCoercion","JSCompiler_inline_result","JSCompiler_temp_const","JSCompiler_inline_result$jscomp$0","getTaskName","name","getOwner","dispatcher","ReactSharedInternals","UnknownOwner","hasValidKey","hasOwnProperty","getter","defineKeyPropWarningGetter","props","displayName","warnAboutAccessingKey","specialPropKeyWarningShown","elementRefGetterWithDeprecationWarning","componentName","didWarnAboutElementRef","ReactElement","self","source","owner","debugStack","debugTask","jsxDEVImpl","isStaticChildren","children","isArrayImpl","validateChildKeys","keys","k","didWarnAboutKeySpread","node","React","require$$0","createTask","callStackForError","unknownOwnerDebugStack","unknownOwnerDebugTask","reactJsxRuntime_development","trackActualOwner","jsxRuntimeModule","require$$1","generateFibonacciSpherePoints","vertexCount","radius","seed","count","r","goldenAngle","positions","seeds","i","t","y","yy","radiusAtY","theta","x","z","pr","lcg","index","state","vertexShader","fragmentShader","getEaser","c2","c4","c5","SphereWaveform","volume","pointSize","shellCount","freezeTime","advanceCount","advanceAmount","size","opacity","rotationX","rotationY","rotationZ","enableRandomishNoise","randomishAmount","enableSineNoise","sineAmount","pulseSize","enableSpin","spinSpeed","randomishSpeed","enableRippleNoise","rippleAmount","rippleSpeed","rippleScale","enableSurfaceRipple","surfaceRippleAmount","surfaceRippleSpeed","surfaceRippleScale","spinAxisX","spinAxisY","maskEnabled","maskRadius","maskFeather","maskInvert","sineSpeed","sineScale","pointColor","glowColor","glowStrength","glowRadiusFactor","enableGradient","gradientColor2","gradientAngle","sizeRandomness","enableArcs","arcMaxCount","arcSpawnRate","arcDuration","arcSpeed","arcSpanDeg","arcThickness","arcFeather","arcBrightness","arcAltitude","micEnvelope","randomishMicModAmount","sineMicModAmount","rippleMicModAmount","surfaceRippleMicModAmount","transition","morph","groupRef","useRef","uniformsRef","prevNowRef","timeAccRef","lastAdvanceRef","arcsRef","animatableKeys","currentValuesRef","startValuesRef","targetValuesRef","animActiveRef","animStartTimeRef","animDurationRef","animEaseRef","onStartRef","onCompleteRef","previousPropsRef","useEffect","enabled","duration","ease","currentProps","currentVisualState","changed","previousValue","newValue","useMemo","arr","THREE","useFrame","stateFrame","uniformsArray","now","dt","diff","arcs","maxArcs","expected","spawns","rem","s","u","v","cx","cy","cz","center","rand","tangent","centers","tangents","t0","dur","spd","span","thick","feath","bright","arcsActive","a","idx3","elapsed","durationMs","te","start","target","startColor","targetColor","lerpedColor","anim","radiusV","pointSizeV","sizeV","opacityV","rotationXV","rotationYV","rotationZV","randomishAmountV","randomishSpeedV","pulseSizeV","sineAmountV","sineSpeedV","sineScaleV","rippleAmountV","rippleSpeedV","rippleScaleV","surfaceRippleAmountV","surfaceRippleSpeedV","surfaceRippleScaleV","spinSpeedV","spinAxisXV","spinAxisYV","maskRadiusV","maskFeatherV","gradientAngleV","sizeRandomnessV","glowStrengthV","glowRadiusFactorV","arcAltitudeV","pointColorV","gradientColor2V","glowColorV","mEnabled","mProgress","toCfg","radiusB","cam","micEnv","randomishAmountFinal","randomishAmountB","sineAmountFinal","sineAmountB","maskRadiusB","maskFeatherB","maskRadiusMix","maskFeatherMix","worldCenter","centerNdc","minHalf","colA","colB","colMix","gradA","gradB","gradMix","angA","angB","angMix","phaseBase","jitter","jsx","jsxs","interpolateConfig","from","to","out","mixNum","b","maybe","fallback","numericKeys","colorKeys","ca","cb","cm","useMorphAnimator","opts","easeFnRef","rafRef","startRef","durRef","fromRef","toRef","setEnabled","useState","progress","setProgress","toState","setToState","cancel","useCallback","play","_a","tick","final","_b","MorphController","onProgress","resolve"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAwV1BC;AAAA;AAAA,EAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","x_google_ignoreList":[0,1,2]}