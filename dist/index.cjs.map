{"version":3,"file":"index.cjs","sources":["../node_modules/react/cjs/react-jsx-runtime.production.js","../node_modules/react/cjs/react-jsx-runtime.development.js","../node_modules/react/jsx-runtime.js","../src/utils/fibonacciSphere.ts","../src/components/SphereWaveform.tsx","../src/animation/easing.ts","../src/animation/useMorphAnimator.ts"],"sourcesContent":["/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\n  void 0 !== config.key && (key = \"\" + config.key);\n  if (\"key\" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n","/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = require(\"react\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      react_stack_bottom_frame: function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !1,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n    exports.jsxs = function (type, config, maybeKey, source, self) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        !0,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","export interface FibonacciSphereResult {\n  positions: Float32Array;\n  seeds: Float32Array;\n}\n\nexport function generateFibonacciSpherePoints(\n  vertexCount: number,\n  radius: number,\n  seed: number = 1\n): FibonacciSphereResult {\n  const count = Math.max(1, Math.floor(Number.isFinite(vertexCount) ? vertexCount : 1));\n  const r = Number.isFinite(radius) ? radius : 1;\n  const phi = (1 + Math.sqrt(5)) / 2;\n  const goldenAngle = (2 - phi) * (2 * Math.PI);\n\n  const positions = new Float32Array(count * 3);\n  const seeds = new Float32Array(count);\n\n  for (let i = 0; i < count; i += 1) {\n    const t = i + 0.5;\n    const y = 1 - (t / Math.max(1, count)) * 2; // y from 1 to -1\n    const yy = Math.min(1, Math.max(-1, y));\n    const radiusAtY = Math.sqrt(Math.max(0, 1 - yy * yy));\n    const theta = goldenAngle * t;\n\n    const x = Math.cos(theta) * radiusAtY;\n    const z = Math.sin(theta) * radiusAtY;\n\n    positions[i * 3 + 0] = x * r;\n    positions[i * 3 + 1] = yy * r;\n    positions[i * 3 + 2] = z * r;\n\n    // simple LCG-based pseudo-random per-vertex seed but deterministic by index and seed param\n    const pr = lcg(i + 1, seed);\n    seeds[i] = pr;\n  }\n\n  return { positions, seeds };\n}\n\nfunction lcg(index: number, seed: number): number {\n  // Deterministic [0,1) based on index and seed\n  const a = 1664525;\n  const c = 1013904223;\n  let state = (seed ^ (index * 2654435761)) >>> 0;\n  state = (Math.imul(a, state) + c) >>> 0;\n  return (state & 0xffffffff) / 0x100000000;\n}\n","import { useEffect, useMemo, useRef } from 'react';\nimport * as THREE from 'three';\nimport { useFrame } from '@react-three/fiber';\nimport { generateFibonacciSpherePoints } from '../utils/fibonacciSphere';\n\n// Removed WaveState - using individual toggles instead\n\nexport interface SphereWaveformProps {\n  vertexCount?: number;\n  volume: number; // 0..1\n  radius?: number; // default 1\n  pointSize?: number; // default 0.04 logical px\n  shellCount?: number; // default 1, number of nested spheres\n  seed?: number; // layout randomness\n  freezeTime?: boolean; // debug: freeze time progression\n  advanceCount?: number; // debug: increments to step time forward manually\n  advanceAmount?: number; // seconds to advance per count (default 1/60)\n  // Global transform\n  size?: number; // overall scene scale multiplier (default 1)\n  opacity?: number; // 0..1 global alpha multiplier\n  rotationX?: number; // degrees\n  rotationY?: number; // degrees\n  rotationZ?: number; // degrees\n  // Composable noise toggles\n  enableRandomishNoise?: boolean;\n  randomishAmount?: number; // 0..1\n  enableSineNoise?: boolean;\n  sineAmount?: number; // 0..1\n  randomishSpeed?: number; // time multiplier for randomish noise\n  pulseSize?: number; // 0..1, controls amplitude of pulse state\n  // Ripple noise specific controls\n  enableRippleNoise?: boolean;\n  rippleAmount?: number; // 0..1\n  rippleSpeed?: number; // 0.1..10\n  rippleScale?: number; // cycles across surface\n  // New toggle-based controls\n  enableSurfaceRipple?: boolean;\n  surfaceRippleAmount?: number;\n  surfaceRippleSpeed?: number;\n  surfaceRippleScale?: number;\n  enableSpin?: boolean;\n  spinSpeed?: number;\n  // Spin axis controls\n  spinAxisX?: number;\n  spinAxisY?: number;\n  // Screen-space circular gradient mask controls\n  maskEnabled?: boolean;\n  // In [0,1], relative to half of the smaller screen dimension (0.5 ~ quarter of min dimension radius)\n  maskRadius?: number;\n  // In [0,1], feather width relative to half of the smaller screen dimension\n  maskFeather?: number;\n  // If true, keeps outside and occludes inside\n  maskInvert?: boolean;\n  // Sine noise specific controls\n  sineSpeed?: number; // temporal frequency multiplier\n  sineScale?: number; // scales aSeed phase contribution\n  // Appearance\n  pointColor?: string; // hex\n  glowColor?: string; // hex for glow\n  glowStrength?: number; // 0..3\n  glowRadiusFactor?: number; // per-side halo thickness as multiple of core radius\n  // Gradient coloring\n  enableGradient?: boolean;\n  gradientColor2?: string;\n  gradientAngle?: number; // degrees 0..360\n  // glowSoftness removed in v20\n  // Point size randomness\n  sizeRandomness?: number; // 0..1 mixes base size with random [0..2]\n  // Arcs (great-circle segments)\n  enableArcs?: boolean;\n  arcMaxCount?: number;\n  arcSpawnRate?: number;\n  arcDuration?: number;\n  arcSpeed?: number;\n  arcSpanDeg?: number;\n  arcThickness?: number;\n  arcFeather?: number;\n  arcBrightness?: number;\n  arcAltitude?: number;\n  // Rendering mode\n  blendingMode?: 'additive' | 'normal';\n  // Modulation sources\n  micEnvelope?: number; // 0..1\n  randomishMicModAmount?: number; // 0..1\n  sineMicModAmount?: number; // 0..1\n  rippleMicModAmount?: number; // 0..1\n  surfaceRippleMicModAmount?: number; // 0..1\n  // Auto-transition of animatable props\n  transition?: TransitionOptions;\n  // Dual-state morphing: compute A and B lanes in-shader and blend by progress\n  morph?: {\n    enabled?: boolean;\n    progress?: number; // 0..1\n    to?: Partial<SphereWaveformProps>;\n  };\n}\n\ninterface Uniforms {\n  uTime: { value: number };\n  uVolume: { value: number };\n  uRadius: { value: number };\n  uRadius2: { value: number };\n  uPointSize: { value: number };\n  uPointSize2: { value: number };\n  uPixelRatio: { value: number };\n  uViewportWidth: { value: number };\n  uViewportHeight: { value: number };\n  uFov: { value: number }; // radians\n  uShellPhase: { value: number };\n  uEnableRandomish: { value: number };\n  uRandomishAmount: { value: number };\n  uRandomishAmount2: { value: number };\n  uEnableSine: { value: number };\n  uSineAmount: { value: number };\n  uSineAmount2: { value: number };\n  uRandomishSpeed: { value: number };\n  uRandomishSpeed2: { value: number };\n  uPulseSize: { value: number };\n  uPulseSize2: { value: number };\n  uOpacity: { value: number };\n  // Size randomness\n  uSizeRandomness: { value: number };\n  // Halo expansion\n  uGlowRadiusFactor: { value: number };\n  uGlowRadiusFactor2: { value: number };\n  // uGlowSoftness removed\n  uExpandHalo: { value: number };\n  // Ripple uniforms\n  uEnableRipple: { value: number };\n  uRippleAmount: { value: number };\n  uRippleAmount2: { value: number };\n  uRippleSpeed: { value: number };\n  uRippleSpeed2: { value: number };\n  uRippleScale: { value: number };\n  uRippleScale2: { value: number };\n  // Surface ripple (tangent displacement)\n  uEnableSurfaceRipple: { value: number };\n  uSurfaceRippleAmount: { value: number };\n  uSurfaceRippleAmount2: { value: number };\n  uSurfaceRippleSpeed: { value: number };\n  uSurfaceRippleSpeed2: { value: number };\n  uSurfaceRippleScale: { value: number };\n  uSurfaceRippleScale2: { value: number };\n  uSurfaceCenter: { value: THREE.Vector3 };\n  // New toggle-based uniforms\n  uEnableSpin: { value: number };\n  uSpinSpeed: { value: number };\n  uSpinSpeed2: { value: number };\n  // Spin axis uniforms\n  uSpinAxisX: { value: number };\n  uSpinAxisY: { value: number };\n  uSpinAxisX2: { value: number };\n  uSpinAxisY2: { value: number };\n  // Screen-space mask uniforms\n  uMaskEnabled: { value: number };\n  uMaskRadiusPx: { value: number };\n  uMaskFeatherPx: { value: number };\n  uMaskInvert: { value: number };\n  uMaskCenterNdc: { value: THREE.Vector2 };\n  // Sine noise uniforms\n  uSineSpeed: { value: number };\n  uSineScale: { value: number };\n  uSineSpeed2: { value: number };\n  uSineScale2: { value: number };\n  // Appearance\n  uColor: { value: THREE.Color };\n  uGlowColor: { value: THREE.Color };\n  uGlowStrength: { value: number };\n  // Gradient\n  uEnableGradient: { value: number };\n  uColor2: { value: THREE.Color };\n  uGradientAngle: { value: number };\n  // Arcs\n  uArcsActive: { value: number };\n  uArcCenters: { value: Float32Array };\n  uArcTangents: { value: Float32Array };\n  uArcT0: { value: Float32Array };\n  uArcDur: { value: Float32Array };\n  uArcSpeed: { value: Float32Array };\n  uArcSpan: { value: Float32Array };\n  uArcThick: { value: Float32Array };\n  uArcFeather: { value: Float32Array };\n  uArcBright: { value: Float32Array };\n  uArcAltitude: { value: number };\n  // Morph blending\n  uMorphProgress: { value: number };\n}\n\nconst vertexShader = /* glsl */ `\nprecision highp float;\nattribute float aSeed;\n\nuniform float uTime;\nuniform float uVolume;\nuniform float uRadius;\nuniform float uRadius2;\nuniform float uPointSize;\nuniform float uPointSize2;\nuniform float uPixelRatio;\nuniform float uViewportWidth;\nuniform float uViewportHeight;\nuniform float uFov;\nuniform float uShellPhase;\nuniform float uSizeRandomness;\nuniform float uGlowRadiusFactor;\nuniform float uGlowRadiusFactor2;\n// softness removed\nuniform int uEnableRandomish;\nuniform float uRandomishAmount;\nuniform float uRandomishAmount2;\nuniform int uEnableSine;\nuniform float uSineAmount;\nuniform float uSineAmount2;\nuniform float uRandomishSpeed;\nuniform float uRandomishSpeed2;\nuniform float uSineSpeed;\nuniform float uSineScale;\nuniform float uSineSpeed2;\nuniform float uSineScale2;\nuniform float uPulseSize;\nuniform float uPulseSize2;\nuniform int uEnableRipple;\nuniform float uRippleAmount;\nuniform float uRippleAmount2;\nuniform float uRippleSpeed;\nuniform float uRippleSpeed2;\nuniform float uRippleScale;\nuniform float uRippleScale2;\nuniform int uEnableSurfaceRipple;\nuniform float uSurfaceRippleAmount;\nuniform float uSurfaceRippleAmount2;\nuniform float uSurfaceRippleSpeed;\nuniform float uSurfaceRippleSpeed2;\nuniform float uSurfaceRippleScale;\nuniform float uSurfaceRippleScale2;\nuniform vec3 uSurfaceCenter;\n// Arcs\nconst int MAX_ARCS = 8;\nuniform int uArcsActive;\nuniform vec3 uArcCenters[MAX_ARCS];\nuniform vec3 uArcTangents[MAX_ARCS];\nuniform float uArcT0[MAX_ARCS];\nuniform float uArcDur[MAX_ARCS];\nuniform float uArcSpeed[MAX_ARCS];\nuniform float uArcSpan[MAX_ARCS];\nuniform float uArcThick[MAX_ARCS];\nuniform float uArcFeather[MAX_ARCS];\nuniform float uArcBright[MAX_ARCS];\nuniform float uArcAltitude;\n// New toggle-based uniforms\nuniform int uEnableSpin;\nuniform float uSpinSpeed;\nuniform float uSpinSpeed2;\n// Spin axis uniforms\nuniform float uSpinAxisX;\nuniform float uSpinAxisY;\nuniform float uSpinAxisX2;\nuniform float uSpinAxisY2;\n// Gradient coloring\nuniform int uEnableGradient;\nuniform float uGradientAngle; // radians\nuniform float uMorphProgress; // 0..1\n\nvarying vec2 vNdc;\nvarying float vArcBoost;\nvarying float vSizeRand;\nvarying float vCoreRadiusNorm;\nvarying float vGradT;\n\n// Simple hash function for deterministic pseudo-random values\nfloat hash(float n) { return fract(sin(n) * 43758.5453); }\nfloat hash(vec3 p) { return hash(dot(p, vec3(127.1, 311.7, 74.7))); }\n\n// Smooth interpolation\nfloat smoothNoise(vec3 p) {\n  vec3 i = floor(p);\n  vec3 f = fract(p);\n  f = f * f * (3.0 - 2.0 * f); // smoothstep\n  \n  float a = hash(i);\n  float b = hash(i + vec3(1.0, 0.0, 0.0));\n  float c = hash(i + vec3(0.0, 1.0, 0.0));\n  float d = hash(i + vec3(1.0, 1.0, 0.0));\n  float e = hash(i + vec3(0.0, 0.0, 1.0));\n  float f1 = hash(i + vec3(1.0, 0.0, 1.0));\n  float g = hash(i + vec3(0.0, 1.0, 1.0));\n  float h = hash(i + vec3(1.0, 1.0, 1.0));\n  \n  return mix(\n    mix(mix(a, b, f.x), mix(c, d, f.x), f.y),\n    mix(mix(e, f1, f.x), mix(g, h, f.x), f.y),\n    f.z\n  );\n}\n\nvoid main() {\n  vec3 initialBase = normalize(position);\n  vec3 baseA = initialBase;\n  vec3 baseB = initialBase;\n\n  // Spin rotates around custom axis when enabled\n  if (uEnableSpin > 0) {\n    float spinAngleA = uTime * uSpinSpeed;\n    float spinAngleB = uTime * uSpinSpeed2;\n    \n    // Convert axis angles to a normalized rotation axis vector\n    // We'll use the axis angles to define the rotation axis\n    float xRadA = radians(uSpinAxisX);\n    float yRadA = radians(uSpinAxisY);\n    float xRadB = radians(uSpinAxisX2);\n    float yRadB = radians(uSpinAxisY2);\n    \n    // Create a rotation axis from the angles\n    // This creates a unit vector pointing in the direction of the rotation axis\n    vec3 axisA = normalize(vec3(\n      sin(yRadA),\n      sin(xRadA),\n      cos(xRadA) * cos(yRadA)\n    ));\n    vec3 axisB = normalize(vec3(\n      sin(yRadB),\n      sin(xRadB),\n      cos(xRadB) * cos(yRadB)\n    ));\n    \n    // Rodrigues' rotation formula to rotate around the custom axis\n    float cA = cos(spinAngleA);\n    float sA = sin(spinAngleA);\n    float omcA = 1.0 - cA; // one minus cosine\n    float cB = cos(spinAngleB);\n    float sB = sin(spinAngleB);\n    float omcB = 1.0 - cB; // one minus cosine\n    \n    // Rotation matrix for rotation around arbitrary axis\n    mat3 RA = mat3(\n      axisA.x * axisA.x * omcA + cA,\n      axisA.x * axisA.y * omcA - axisA.z * sA,\n      axisA.x * axisA.z * omcA + axisA.y * sA,\n      axisA.y * axisA.x * omcA + axisA.z * sA,\n      axisA.y * axisA.y * omcA + cA,\n      axisA.y * axisA.z * omcA - axisA.x * sA,\n      axisA.z * axisA.x * omcA - axisA.y * sA,\n      axisA.z * axisA.y * omcA + axisA.x * sA,\n      axisA.z * axisA.z * omcA + cA\n    );\n    mat3 RB = mat3(\n      axisB.x * axisB.x * omcB + cB,\n      axisB.x * axisB.y * omcB - axisB.z * sB,\n      axisB.x * axisB.z * omcB + axisB.y * sB,\n      axisB.y * axisB.x * omcB + axisB.z * sB,\n      axisB.y * axisB.y * omcB + cB,\n      axisB.y * axisB.z * omcB - axisB.x * sB,\n      axisB.z * axisB.x * omcB - axisB.y * sB,\n      axisB.z * axisB.y * omcB + axisB.x * sB,\n      axisB.z * axisB.z * omcB + cB\n    );\n    \n    // Apply the rotation\n    baseA = RA * baseA;\n    baseB = RB * baseB;\n  }\n\n  // Base time\n  float t = uTime * 0.4 + uShellPhase;\n  \n  float nRandomish = 0.0;\n  if (uEnableRandomish > 0) {\n    float spatialScale = mix(0.5, 10.0, uPulseSize);\n    float tR = t * uRandomishSpeed;\n    vec3 p = baseA * spatialScale + vec3(aSeed * 0.1, aSeed * 0.2, tR);\n    nRandomish = (smoothNoise(p) * 2.0 - 1.0) * uRandomishAmount;\n  }\n  float nSine = 0.0;\n  if (uEnableSine > 0) {\n    nSine = sin(t * uSineSpeed + aSeed * 6.2831853 * uSineScale) * uSineAmount;\n  }\n  // Ripple along surface: traveling wave around Z axis using longitude\n  float nRipple = 0.0;\n  if (uEnableRipple > 0) {\n    float tR = t * uRippleSpeed;\n    float longitude = atan(baseA.y, baseA.x); // [-pi, pi]\n    float wave = sin(longitude * uRippleScale - tR);\n    nRipple = wave * uRippleAmount;\n  }\n  // Surface ripple displacement along tangent directions (keeps radius ~constant)\n  vec3 tangentDisplaced = vec3(0.0);\n  if (uEnableSurfaceRipple > 0) {\n    vec3 N = normalize(baseA);\n    // Geodesic angle from moving center\n    float angle = acos(clamp(dot(N, normalize(uSurfaceCenter)), -1.0, 1.0));\n    float phase = angle * uSurfaceRippleScale - t * uSurfaceRippleSpeed;\n    float wave = sin(phase);\n    // Tangent direction towards center along the surface\n    vec3 toCenterTangent = normalize(uSurfaceCenter - dot(uSurfaceCenter, N) * N);\n    // In case of degeneracy near alignment, fall back to arbitrary tangent\n    if (!all(greaterThan(abs(toCenterTangent), vec3(1e-6)))) {\n      vec3 alt = vec3(1.0, 0.0, 0.0);\n      toCenterTangent = normalize(cross(N, cross(alt, N)));\n    }\n    vec3 offset = toCenterTangent * (wave * uSurfaceRippleAmount * 0.25);\n    vec3 surf = normalize(baseA + offset);\n    tangentDisplaced = surf - baseA;\n  }\n  float n = nRandomish + nSine + nRipple;\n\n  // Map n in [-1,1] to multiplicative radius: 1 + n*volume\n  float radialFactorA = 1.0 + n * clamp(uVolume, 0.0, 1.0);\n  radialFactorA = clamp(radialFactorA, 0.0, 2.5);\n  vec3 displacedA = (baseA + tangentDisplaced) * (uRadius * radialFactorA);\n\n  // Lane B\n  float nRandomishB = 0.0;\n  float nSineB = 0.0;\n  float nRippleB = 0.0;\n  vec3 tangentDisplacedB = vec3(0.0);\n  if (uEnableRandomish > 0) {\n    float spatialScaleB = mix(0.5, 10.0, uPulseSize2);\n    float tRB = t * uRandomishSpeed2;\n    vec3 pB = baseB * spatialScaleB + vec3(aSeed * 0.1, aSeed * 0.2, tRB);\n    nRandomishB = (smoothNoise(pB) * 2.0 - 1.0) * uRandomishAmount2;\n  }\n  if (uEnableSine > 0) {\n    nSineB = sin(t * uSineSpeed2 + aSeed * 6.2831853 * uSineScale2) * uSineAmount2;\n  }\n  if (uEnableRipple > 0) {\n    float tRB = t * uRippleSpeed2;\n    float longitudeB = atan(baseB.y, baseB.x);\n    float waveB = sin(longitudeB * uRippleScale2 - tRB);\n    nRippleB = waveB * uRippleAmount2;\n  }\n  if (uEnableSurfaceRipple > 0) {\n    vec3 N2 = normalize(baseB);\n    float angle2 = acos(clamp(dot(N2, normalize(uSurfaceCenter)), -1.0, 1.0));\n    float phase2 = angle2 * uSurfaceRippleScale2 - t * uSurfaceRippleSpeed2;\n    float wave2 = sin(phase2);\n    vec3 toCenterTangent2 = normalize(uSurfaceCenter - dot(uSurfaceCenter, N2) * N2);\n    if (!all(greaterThan(abs(toCenterTangent2), vec3(1e-6)))) {\n      vec3 alt2 = vec3(1.0, 0.0, 0.0);\n      toCenterTangent2 = normalize(cross(N2, cross(alt2, N2)));\n    }\n    vec3 offset2 = toCenterTangent2 * (wave2 * uSurfaceRippleAmount2 * 0.25);\n    vec3 surf2 = normalize(baseB + offset2);\n    tangentDisplacedB = surf2 - baseB;\n  }\n  float nB = nRandomishB + nSineB + nRippleB;\n  float radialFactorB = 1.0 + nB * clamp(uVolume, 0.0, 1.0);\n  radialFactorB = clamp(radialFactorB, 0.0, 2.5);\n  vec3 displacedB = (baseB + tangentDisplacedB) * (uRadius2 * radialFactorB);\n\n  float s = clamp(uMorphProgress, 0.0, 1.0);\n  // Spherical interpolation between lane directions to avoid passing through the origin\n  vec3 dirA = normalize(baseA + tangentDisplaced);\n  vec3 dirB = normalize(baseB + tangentDisplacedB);\n  float dotAB = clamp(dot(dirA, dirB), -1.0, 1.0);\n  float theta = acos(dotAB);\n  vec3 dir;\n  if (theta < 1e-4) {\n    dir = dirA;\n  } else {\n    float sinTheta = sin(theta);\n    float wA = sin((1.0 - s) * theta) / sinTheta;\n    float wB = sin(s * theta) / sinTheta;\n    dir = normalize(wA * dirA + wB * dirB);\n  }\n  float radiusMix = mix(uRadius * radialFactorA, uRadius2 * radialFactorB, s);\n  vec3 displaced = dir * radiusMix;\n  vec3 base = dir;\n\n  // Arcs influence: accumulate alpha boost and small radial puff\n  vArcBoost = 0.0;\n  if (uArcsActive > 0) {\n    for (int i = 0; i < MAX_ARCS; i++) {\n      if (i >= uArcsActive) { continue; }\n      float age = uTime - uArcT0[i];\n      if (age < 0.0 || age > uArcDur[i]) { continue; }\n      float tnorm = clamp(age / max(0.0001, uArcDur[i]), 0.0, 1.0);\n      // Temporal fade in/out\n      float fade = smoothstep(0.0, 0.2, tnorm) * (1.0 - smoothstep(0.8, 1.0, tnorm));\n      // Great-circle param along arc\n      vec3 C = normalize(uArcCenters[i]);\n      vec3 T = normalize(uArcTangents[i]);\n      vec3 B = cross(C, T);\n      vec3 Np = normalize(base - dot(base, C) * C);\n      float phi = atan(dot(Np, B), dot(Np, T));\n      float phiHead = -tnorm * uArcSpeed[i];\n      float halfSpan = uArcSpan[i] * 0.5;\n      float centerDist = abs(atan(sin(phi - phiHead), cos(phi - phiHead)));\n      float withinSpan = 1.0 - smoothstep(halfSpan, halfSpan + uArcFeather[i], centerDist);\n      float planeDist = abs(dot(base, C));\n      float withinThick = 1.0 - smoothstep(uArcThick[i], uArcThick[i] + uArcFeather[i], planeDist);\n      // Altitude profile along arc length: 0 at ends, 1 at center\n      float along = clamp(1.0 - centerDist / max(1e-4, halfSpan), 0.0, 1.0);\n      float altShape = sin(along * 3.14159265); // 0..1..0\n      float mask = withinSpan * withinThick * fade;\n      if (mask > 0.0) {\n        vArcBoost += mask * uArcBright[i];\n        // Altitude measured in multiples of sphere radius (uRadius)\n        displaced += base * (uArcAltitude * uRadius * altShape * withinThick * fade);\n      }\n    }\n  }\n\n  vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);\n  gl_Position = projectionMatrix * mvPosition;\n  vNdc = gl_Position.xy / gl_Position.w;\n\n  // FOV-correct perspective size attenuation\n  float scale = uViewportHeight / (2.0 * tan(uFov * 0.5));\n  // Per-vertex size randomness: [0..2] factor mixed by uSizeRandomness\n  float rand01 = hash(aSeed);\n  float sizeFactor = mix(1.0, rand01 * 2.0, clamp(uSizeRandomness, 0.0, 1.0));\n  vSizeRand = sizeFactor;\n  float pointSizeMix = mix(uPointSize, uPointSize2, s);\n  float glowMix = mix(uGlowRadiusFactor, uGlowRadiusFactor2, s);\n  float basePx = (pointSizeMix * sizeFactor) * uPixelRatio * scale / -mvPosition.z;\n  float haloPx = max(0.0, glowMix) * basePx;\n  float expanded = basePx + 2.0 * haloPx;\n  vCoreRadiusNorm = (expanded > 0.0) ? clamp(basePx / expanded, 0.0, 1.0) : 1.0;\n  gl_PointSize = clamp(expanded, 0.0, 2048.0);\n  // Compute gradient mix factor from original static position so color is stable\n  if (uEnableGradient > 0) {\n    float ang = uGradientAngle; // radians\n    // 3D direction around Y axis (full great-circle variation)\n    vec3 dir3 = normalize(vec3(cos(ang), 0.0, sin(ang)));\n    float proj = dot(normalize(initialBase), dir3);\n    vGradT = clamp(proj * 0.5 + 0.5, 0.0, 1.0);\n  } else {\n    vGradT = 0.0;\n  }\n}\n`;\n\nconst fragmentShader = /* glsl */ `\nprecision highp float;\nuniform float uViewportWidth;\nuniform float uViewportHeight;\nuniform int uMaskEnabled;\nuniform float uMaskRadiusPx;\nuniform float uMaskFeatherPx;\nuniform int uMaskInvert;\nuniform vec2 uMaskCenterNdc;\nuniform vec3 uColor;\nuniform vec3 uColor2;\nuniform int uEnableGradient;\nuniform float uOpacity;\nuniform vec3 uGlowColor;\nuniform float uGlowStrength;\nvarying vec2 vNdc;\nvarying float vArcBoost;\nvarying float vSizeRand;\nvarying float vCoreRadiusNorm;\nvarying float vGradT;\nvoid main() {\n  vec2 uv = gl_PointCoord * 2.0 - 1.0;\n  float r2 = dot(uv, uv);\n  float r = sqrt(r2);\n  // Discard square sprite corners so depth writes don't clip as boxes\n  if (r > 1.0) { discard; }\n  // Core disc alpha with a thicker feather to avoid precision artifacts\n  float alpha = 1.0 - smoothstep(vCoreRadiusNorm, vCoreRadiusNorm + 0.05, r);\n  // Screen-space circular mask shared by color and alpha\n  float screenMask = 1.0;\n  if (uMaskEnabled > 0) {\n    // Pixel-space distance to mask center (attached to sphere center in NDC)\n    vec2 deltaPx = vec2((vNdc.x - uMaskCenterNdc.x) * 0.5 * uViewportWidth, (vNdc.y - uMaskCenterNdc.y) * 0.5 * uViewportHeight);\n    float distPx = length(deltaPx);\n    float inside = 1.0 - smoothstep(uMaskRadiusPx, uMaskRadiusPx + max(0.0001, uMaskFeatherPx), distPx);\n    screenMask = (uMaskInvert > 0) ? (1.0 - inside) : inside;\n    alpha *= clamp(screenMask, 0.0, 1.0);\n  }\n  alpha *= min(3.0, 1.0 + vArcBoost);\n  alpha *= clamp(uOpacity, 0.0, 1.0);\n  // Edge ring emission to tint bloom without altering core opacity\n  float inner = vCoreRadiusNorm;\n  float end = mix(inner, 1.0, 0.3);\n  float ring = 1.0 - smoothstep(inner, end, r);\n  float emission = ring * clamp(uGlowStrength, 0.0, 3.0);\n  vec3 baseColor = (uEnableGradient > 0) ? mix(uColor, uColor2, clamp(vGradT, 0.0, 1.0)) : uColor;\n  vec3 color = (baseColor + uGlowColor * emission * 0.4) * screenMask;\n  float outAlpha = alpha;\n  gl_FragColor = vec4(color, outAlpha);\n}\n`;\n\n// Removed getMode function - using toggles instead\n\ntype Arc = {\n  center: THREE.Vector3;\n  tangent: THREE.Vector3;\n  t0: number;\n  duration: number;\n  speed: number;\n  span: number;\n  thickness: number;\n  feather: number;\n  brightness: number;\n};\n\ntype AnimEase =\n  | 'linear'\n  | 'power1.in' | 'power1.out' | 'power1.inOut'\n  | 'power2.in' | 'power2.out' | 'power2.inOut'\n  | 'power3.in' | 'power3.out' | 'power3.inOut'\n  | 'power4.in' | 'power4.out' | 'power4.inOut'\n  | 'sine.in' | 'sine.out' | 'sine.inOut'\n  | 'expo.in' | 'expo.out' | 'expo.inOut'\n  | 'back.in' | 'back.out' | 'back.inOut'\n  | 'elastic.in' | 'elastic.out' | 'elastic.inOut'\n  | 'bounce.in' | 'bounce.out' | 'bounce.inOut';\n\nexport interface TransitionOptions {\n  enabled?: boolean;\n  mode?: 'lerp';\n  duration?: number; // seconds\n  ease?: AnimEase;\n  onStart?: () => void;\n  onComplete?: () => void;\n}\n\nfunction getEaser(name: AnimEase | undefined): (t: number) => number {\n  switch (name) {\n    case 'linear':\n      return (t: number) => t;\n    case 'power1.in':\n      return (t: number) => t * t;\n    case 'power1.out':\n      return (t: number) => 1 - Math.pow(1 - t, 2);\n    case 'power1.inOut':\n      return (t: number) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);\n    case 'power2.in':\n      return (t: number) => t * t * t;\n    case 'power2.out':\n      return (t: number) => 1 - Math.pow(1 - t, 3);\n    case 'power2.inOut':\n      return (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);\n    case 'power3.in':\n      return (t: number) => t * t * t * t;\n    case 'power3.out':\n      return (t: number) => 1 - Math.pow(1 - t, 4);\n    case 'power3.inOut':\n      return (t: number) => (t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2);\n    case 'power4.in':\n      return (t: number) => t * t * t * t * t;\n    case 'power4.out':\n      return (t: number) => 1 - Math.pow(1 - t, 5);\n    case 'power4.inOut':\n      return (t: number) => (t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2);\n    case 'sine.in':\n      return (t: number) => 1 - Math.cos((t * Math.PI) / 2);\n    case 'sine.out':\n      return (t: number) => Math.sin((t * Math.PI) / 2);\n    case 'sine.inOut':\n      return (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;\n    case 'expo.in':\n      return (t: number) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1)));\n    case 'expo.out':\n      return (t: number) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n    case 'expo.inOut':\n      return (t: number) => {\n        if (t === 0 || t === 1) return t;\n        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;\n      };\n    case 'back.in':\n      return (t: number) => 2.7 * t * t * t - 1.7 * t * t;\n    case 'back.out':\n      return (t: number) => 1 + 2.7 * Math.pow(t - 1, 3) + 1.7 * Math.pow(t - 1, 2);\n    case 'back.inOut':\n      return (t: number) => {\n        const c1 = 1.70158;\n        const c2 = c1 * 1.525;\n        return t < 0.5\n          ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n          : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n      };\n    case 'elastic.in':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n      };\n    case 'elastic.out':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n      };\n    case 'elastic.inOut':\n      return (t: number) => {\n        const c5 = (2 * Math.PI) / 4.5;\n        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5\n          ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n          : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1;\n      };\n    case 'bounce.in':\n      return (t: number) => 1 - getEaser('bounce.out')(1 - t);\n    case 'bounce.out':\n      return (t: number) => {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (t < 1 / d1) {\n          return n1 * t * t;\n        } else if (t < 2 / d1) {\n          return n1 * (t -= 1.5 / d1) * t + 0.75;\n        } else if (t < 2.5 / d1) {\n          return n1 * (t -= 2.25 / d1) * t + 0.9375;\n        } else {\n          return n1 * (t -= 2.625 / d1) * t + 0.984375;\n        }\n      };\n    case 'bounce.inOut':\n      return (t: number) => t < 0.5\n        ? (1 - getEaser('bounce.out')(1 - 2 * t)) / 2\n        : (1 + getEaser('bounce.out')(2 * t - 1)) / 2;\n    default:\n      return (t: number) => t;\n  }\n}\n\nexport function SphereWaveform({\n  vertexCount = 400,\n  volume,\n  radius = 1,\n  pointSize = 0.04,\n  shellCount = 1,\n  seed = 1,\n  freezeTime = false,\n  advanceCount = 0,\n  advanceAmount = 1 / 60,\n  size = 1,\n  opacity = 1,\n  rotationX = 0,\n  rotationY = 0,\n  rotationZ = 0,\n  enableRandomishNoise = true,\n  randomishAmount = 1,\n  enableSineNoise = false,\n  sineAmount = 0,\n  pulseSize = 1,\n  enableSpin = false,\n  spinSpeed = 0.35,\n  randomishSpeed = 1.8,\n  enableRippleNoise = false,\n  rippleAmount = 0.0,\n  rippleSpeed = 1.5,\n  rippleScale = 3.0,\n  enableSurfaceRipple = false,\n  surfaceRippleAmount = 0.0,\n  surfaceRippleSpeed = 1.5,\n  surfaceRippleScale = 3.0,\n  spinAxisX = 0,\n  spinAxisY = 0,\n  maskEnabled = false,\n  maskRadius = 0.5,\n  maskFeather = 0.2,\n  maskInvert = false,\n  sineSpeed = 1.7,\n  sineScale = 1.0,\n  pointColor = '#ffffff',\n  glowColor = '#ffffff',\n  glowStrength = 0.0,\n  glowRadiusFactor = 0,\n  enableGradient = false,\n  gradientColor2 = '#ffffff',\n  gradientAngle = 0,\n  // softness removed\n  sizeRandomness = 0.0,\n  enableArcs = false,\n  arcMaxCount = 4,\n  arcSpawnRate = 0.25,\n  arcDuration = 4.0,\n  arcSpeed = 1.5,\n  arcSpanDeg = 60,\n  arcThickness = 0.06,\n  arcFeather = 0.04,\n  arcBrightness = 1.0,\n  arcAltitude = 0.02,\n  // blendingMode kept for API stability\n  // Modulation inputs (optional)\n  micEnvelope = 0,\n  randomishMicModAmount = 0,\n  sineMicModAmount = 0,\n  rippleMicModAmount = 0,\n  surfaceRippleMicModAmount = 0,\n  transition,\n  morph,\n}: SphereWaveformProps) {\n  const groupRef = useRef<THREE.Group | null>(null);\n  const uniformsRef = useRef<Uniforms[] | null>(null);\n  const prevNowRef = useRef<number | null>(null);\n  const timeAccRef = useRef<number>(0);\n  const lastAdvanceRef = useRef<number>(advanceCount);\n  const arcsRef = useRef<Arc[]>([]);\n\n  // Auto-transition state - only animate visual output props, not noise parameters\n  // Noise parameters (speeds, scales) create artifacts when interpolated\n  // Keep all effects enabled, animate amounts (zero = off)\n  type AnimatableKey = keyof SphereWaveformProps;\n  const animatableKeys: AnimatableKey[] = [\n    'radius','pointSize','size','opacity',\n    'rotationX','rotationY','rotationZ',\n    'randomishAmount','pulseSize', // exclude randomishSpeed\n    'sineAmount', // exclude sineSpeed, sineScale\n    'rippleAmount', // exclude rippleSpeed, rippleScale\n    'surfaceRippleAmount', // exclude surfaceRippleSpeed, surfaceRippleScale\n    'spinSpeed','spinAxisX','spinAxisY',\n    'maskRadius','maskFeather',\n    'gradientAngle','sizeRandomness',\n    'glowStrength','glowRadiusFactor',\n    'arcSpawnRate','arcDuration','arcSpeed','arcSpanDeg','arcThickness','arcFeather','arcBrightness','arcAltitude',\n    'pointColor','gradientColor2','glowColor',\n  ];\n\n  const currentValuesRef = useRef<Record<string, any> | null>(null);\n  const startValuesRef = useRef<Record<string, any> | null>(null);\n  const targetValuesRef = useRef<Record<string, any> | null>(null);\n\n  const animActiveRef = useRef<boolean>(false);\n  const animStartTimeRef = useRef<number>(0);\n  const animDurationRef = useRef<number>(0.6);\n  const animEaseRef = useRef<(t: number) => number>((t: number) => t);\n  const onStartRef = useRef<(() => void) | undefined>(undefined);\n  const onCompleteRef = useRef<(() => void) | undefined>(undefined);\n  const previousPropsRef = useRef<Record<string, any> | null>(null);\n\n  // Initialize/handle prop changes → targets and (optionally) start tween\n  useEffect(() => {\n    // Only run internal transition when explicitly enabled\n    const enabled = transition?.enabled === true;\n    const duration = (transition?.duration ?? 0.6);\n    const ease = getEaser(transition?.ease ?? 'power2.inOut');\n    onStartRef.current = transition?.onStart;\n    onCompleteRef.current = transition?.onComplete;\n    animDurationRef.current = Math.max(0, duration);\n    animEaseRef.current = ease;\n\n    // Collect current prop values (only animatable ones)\n    const currentProps = {\n      radius, pointSize, size, opacity,\n      rotationX, rotationY, rotationZ,\n      randomishAmount, pulseSize,\n      sineAmount,\n      rippleAmount,\n      surfaceRippleAmount,\n      spinSpeed, spinAxisX, spinAxisY,\n      maskRadius, maskFeather,\n      gradientAngle, sizeRandomness,\n      glowStrength, glowRadiusFactor,\n      arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n      pointColor, gradientColor2, glowColor,\n    };\n\n    if (!currentValuesRef.current) {\n      // First render - initialize with current visual state (not target props)\n      // This ensures transitions start from the actual current visual state\n      const currentVisualState = {\n        radius, pointSize, size, opacity,\n        rotationX, rotationY, rotationZ,\n        randomishAmount, pulseSize,\n        sineAmount,\n        rippleAmount,\n        surfaceRippleAmount,\n        spinSpeed, spinAxisX, spinAxisY,\n        maskRadius, maskFeather,\n        gradientAngle, sizeRandomness,\n        glowStrength, glowRadiusFactor,\n        arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n        pointColor, gradientColor2, glowColor,\n      };\n      console.log('=== INITIALIZING currentValuesRef ===');\n      console.log('currentVisualState:', currentVisualState);\n      \n      currentValuesRef.current = { ...currentVisualState };\n      startValuesRef.current = { ...currentVisualState };\n      targetValuesRef.current = { ...currentVisualState };\n      animActiveRef.current = false;\n      \n      console.log('currentValuesRef.current after init:', currentValuesRef.current);\n      console.log('=== END INIT ===');\n      return;\n    }\n\n    // Detect changes by comparing with previous props\n    let changed = false;\n    if (previousPropsRef.current) {\n      for (const key of animatableKeys) {\n        const previousValue = previousPropsRef.current[key];\n        const newValue = (currentProps as any)[key];\n        \n        if (typeof previousValue === 'number' && typeof newValue === 'number') {\n          if (Math.abs(previousValue - newValue) > 1e-9) {\n            changed = true;\n            break;\n          }\n        } else if (typeof previousValue === 'string' && typeof newValue === 'string') {\n          if (previousValue !== newValue) {\n            changed = true;\n            break;\n          }\n        }\n      }\n    } else {\n      // First time detecting changes - always start transition\n      changed = true;\n    }\n\n    if (!changed) {\n      // Update previous props but don't start animation\n      previousPropsRef.current = { ...currentProps };\n      return;\n    }\n\n    if (!enabled || animDurationRef.current === 0) {\n      // Snap to target values\n      console.log('=== SNAPPING VALUES (NO TRANSITION) ===');\n      console.log('enabled:', enabled, 'duration:', animDurationRef.current);\n      console.log('transition:', transition);\n      console.log('currentValuesRef.current BEFORE snap:', currentValuesRef.current);\n      console.log('currentProps (target):', currentProps);\n      \n      currentValuesRef.current = { ...currentProps };\n      targetValuesRef.current = { ...currentProps };\n      previousPropsRef.current = { ...currentProps };\n      animActiveRef.current = false;\n      \n      console.log('currentValuesRef.current AFTER snap:', currentValuesRef.current);\n      console.log('=== END SNAP ===');\n      return;\n    }\n\n    // Start animation from current animated values → new target\n    console.log('=== STARTING TRANSITION ===');\n    console.log('currentValuesRef.current BEFORE transition start:', currentValuesRef.current);\n    console.log('currentProps (target):', currentProps);\n    \n    startValuesRef.current = { ...currentValuesRef.current };\n    targetValuesRef.current = { ...currentProps };\n    previousPropsRef.current = { ...currentProps };\n    animStartTimeRef.current = performance.now();\n    animActiveRef.current = true;\n    \n    console.log('startValuesRef.current:', startValuesRef.current);\n    console.log('targetValuesRef.current:', targetValuesRef.current);\n    console.log('=== END TRANSITION START ===');\n    \n    try { onStartRef.current && onStartRef.current(); } catch {}\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [\n    transition?.enabled, transition?.duration, transition?.ease,\n    radius, pointSize, size, opacity,\n    rotationX, rotationY, rotationZ,\n    randomishAmount, pulseSize,\n    sineAmount,\n    rippleAmount,\n    surfaceRippleAmount,\n    spinSpeed, spinAxisX, spinAxisY,\n    maskRadius, maskFeather,\n    gradientAngle, sizeRandomness,\n    glowStrength, glowRadiusFactor,\n    arcSpawnRate, arcDuration, arcSpeed, arcSpanDeg, arcThickness, arcFeather, arcBrightness, arcAltitude,\n    pointColor, gradientColor2, glowColor,\n  ]);\n\n  const { positions, seeds } = useMemo(\n    () => generateFibonacciSpherePoints(vertexCount, radius, seed),\n    [vertexCount, radius, seed]\n  );\n\n  // Lazily create uniforms per shell and keep array length in sync without\n  // replacing existing objects (to avoid freezing on shell changes).\n  if (uniformsRef.current === null) {\n    uniformsRef.current = []\n  }\n  {\n    const count = Math.max(1, Math.floor(shellCount))\n    const arr = uniformsRef.current\n    // Grow\n    for (let i = arr.length; i < count; i++) {\n      arr.push({\n        uTime: { value: 0 },\n        uVolume: { value: 0 },\n        uRadius: { value: radius * (i === 0 ? 1 : 1 + i * 0.2) },\n        uRadius2: { value: radius * (i === 0 ? 1 : 1 + i * 0.2) },\n        uPointSize: { value: pointSize },\n        uPointSize2: { value: pointSize },\n        uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },\n        uViewportWidth: { value: window.innerWidth },\n        uViewportHeight: { value: window.innerHeight },\n        uFov: { value: (60 * Math.PI) / 180 },\n        uShellPhase: { value: 0 },\n        uSizeRandomness: { value: sizeRandomness },\n        uEnableRandomish: { value: enableRandomishNoise ? 1 : 0 },\n        uRandomishAmount: { value: randomishAmount },\n        uRandomishAmount2: { value: randomishAmount },\n        uEnableSine: { value: enableSineNoise ? 1 : 0 },\n        uSineAmount: { value: sineAmount },\n        uSineAmount2: { value: sineAmount },\n        uRandomishSpeed: { value: randomishSpeed },\n        uRandomishSpeed2: { value: randomishSpeed },\n        uPulseSize: { value: pulseSize },\n        uPulseSize2: { value: pulseSize },\n        uOpacity: { value: opacity },\n        // Size randomness\n        \n        // Halo expansion\n        uGlowRadiusFactor: { value: glowRadiusFactor },\n        uExpandHalo: { value: 1 },\n        uGlowRadiusFactor2: { value: glowRadiusFactor },\n        // uGlowSoftness removed\n        // Ripple uniforms\n        uEnableRipple: { value: enableRippleNoise ? 1 : 0 },\n        uRippleAmount: { value: rippleAmount },\n        uRippleAmount2: { value: rippleAmount },\n        uRippleSpeed: { value: rippleSpeed },\n        uRippleSpeed2: { value: rippleSpeed },\n        uRippleScale: { value: rippleScale },\n        uRippleScale2: { value: rippleScale },\n        // Surface ripple (tangent displacement)\n        uEnableSurfaceRipple: { value: enableSurfaceRipple ? 1 : 0 },\n        uSurfaceRippleAmount: { value: surfaceRippleAmount },\n        uSurfaceRippleAmount2: { value: surfaceRippleAmount },\n        uSurfaceRippleSpeed: { value: surfaceRippleSpeed },\n        uSurfaceRippleSpeed2: { value: surfaceRippleSpeed },\n        uSurfaceRippleScale: { value: surfaceRippleScale },\n        uSurfaceRippleScale2: { value: surfaceRippleScale },\n        uSurfaceCenter: { value: new THREE.Vector3(0, 0, 1) },\n        // New toggle-based uniforms\n        uEnableSpin: { value: enableSpin ? 1 : 0 },\n        uSpinSpeed: { value: spinSpeed },\n        uSpinSpeed2: { value: spinSpeed },\n        // Spin axis uniforms\n        uSpinAxisX: { value: spinAxisX },\n        uSpinAxisY: { value: spinAxisY },\n        uSpinAxisX2: { value: spinAxisX },\n        uSpinAxisY2: { value: spinAxisY },\n        // Screen-space mask uniforms\n        uMaskEnabled: { value: maskEnabled ? 1 : 0 },\n        uMaskRadiusPx: { value: 0 },\n        uMaskFeatherPx: { value: 0 },\n        uMaskInvert: { value: maskInvert ? 1 : 0 },\n        uMaskCenterNdc: { value: new THREE.Vector2(0, 0) },\n        // Sine noise uniforms\n        uSineSpeed: { value: sineSpeed },\n        uSineScale: { value: sineScale },\n        uSineSpeed2: { value: sineSpeed },\n        uSineScale2: { value: sineScale },\n        // Appearance\n        uColor: { value: new THREE.Color(pointColor) },\n        uColor2: { value: new THREE.Color(gradientColor2) },\n        uEnableGradient: { value: enableGradient ? 1 : 0 },\n        uGradientAngle: { value: 0 },\n        uGlowColor: { value: new THREE.Color(glowColor) },\n        uGlowStrength: { value: glowStrength },\n        uMorphProgress: { value: 0 },\n        \n        uArcsActive: { value: 0 },\n        uArcCenters: { value: new Float32Array(8 * 3) },\n        uArcTangents: { value: new Float32Array(8 * 3) },\n        uArcT0: { value: new Float32Array(8) },\n        uArcDur: { value: new Float32Array(8) },\n        uArcSpeed: { value: new Float32Array(8) },\n        uArcSpan: { value: new Float32Array(8) },\n        uArcThick: { value: new Float32Array(8) },\n        uArcFeather: { value: new Float32Array(8) },\n        uArcBright: { value: new Float32Array(8) },\n        uArcAltitude: { value: arcAltitude },\n      })\n    }\n    // Shrink\n    if (arr.length > count) {\n      arr.length = count\n    }\n  }\n\n  useFrame((stateFrame) => {\n    const uniformsArray = uniformsRef.current!;\n    const now = stateFrame.clock.getElapsedTime();\n    if (prevNowRef.current === null) {\n      prevNowRef.current = now;\n      timeAccRef.current = now;\n      lastAdvanceRef.current = advanceCount;\n    }\n    const dt = Math.max(0, now - prevNowRef.current);\n    prevNowRef.current = now;\n\n    if (freezeTime) {\n      if (advanceCount !== lastAdvanceRef.current) {\n        const diff = advanceCount - lastAdvanceRef.current;\n        timeAccRef.current += diff * advanceAmount;\n        lastAdvanceRef.current = advanceCount;\n      }\n    } else {\n      timeAccRef.current += dt;\n      lastAdvanceRef.current = advanceCount;\n    }\n\n    // Stateful random arc spawner\n    const arcs = arcsRef.current;\n    // Cull expired\n    for (let i = arcs.length - 1; i >= 0; i--) {\n      if (timeAccRef.current - arcs[i].t0 > arcs[i].duration) {\n        arcs.splice(i, 1);\n      }\n    }\n    const maxArcs = Math.min(8, Math.max(0, Math.floor(arcMaxCount)));\n    if (enableArcs && arcSpawnRate > 0 && arcs.length < maxArcs && dt > 0) {\n      let expected = arcSpawnRate * dt;\n      let spawns = Math.floor(expected);\n      const rem = expected - spawns;\n      if (Math.random() < rem) spawns += 1;\n      for (let s = 0; s < spawns && arcs.length < maxArcs; s++) {\n        // Random center on unit sphere\n        const u = Math.random();\n        const v = Math.random();\n        const theta = 2 * Math.PI * u;\n        const z = 2 * v - 1;\n        const r = Math.sqrt(Math.max(0, 1 - z * z));\n        const cx = r * Math.cos(theta);\n        const cy = r * Math.sin(theta);\n        const cz = z;\n        const center = new THREE.Vector3(cx, cy, cz).normalize();\n        // Random direction orthogonal to center\n        const rand = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\n        let tangent = new THREE.Vector3().crossVectors(center, rand);\n        if (tangent.lengthSq() < 1e-6) {\n          tangent = new THREE.Vector3().crossVectors(center, new THREE.Vector3(1, 0, 0));\n        }\n        tangent.normalize();\n        arcs.push({\n          center,\n          tangent,\n          t0: timeAccRef.current,\n          duration: arcDuration,\n          speed: arcSpeed,\n          span: (Math.max(0, arcSpanDeg) * Math.PI) / 180,\n          thickness: Math.max(0, arcThickness),\n          feather: Math.max(0.0001, arcFeather),\n          brightness: Math.max(0, arcBrightness),\n        });\n      }\n    }\n\n    // Pack arc uniforms\n    const centers = new Float32Array(8 * 3);\n    const tangents = new Float32Array(8 * 3);\n    const t0 = new Float32Array(8);\n    const dur = new Float32Array(8);\n    const spd = new Float32Array(8);\n    const span = new Float32Array(8);\n    const thick = new Float32Array(8);\n    const feath = new Float32Array(8);\n    const bright = new Float32Array(8);\n    const arcsActive = Math.min(arcs.length, 8);\n    for (let i = 0; i < arcsActive; i++) {\n      const a = arcs[i];\n      const idx3 = i * 3;\n      centers[idx3 + 0] = a.center.x; centers[idx3 + 1] = a.center.y; centers[idx3 + 2] = a.center.z;\n      tangents[idx3 + 0] = a.tangent.x; tangents[idx3 + 1] = a.tangent.y; tangents[idx3 + 2] = a.tangent.z;\n      t0[i] = a.t0;\n      dur[i] = a.duration;\n      spd[i] = a.speed;\n      span[i] = a.span;\n      thick[i] = a.thickness;\n      feath[i] = a.feather;\n      bright[i] = a.brightness;\n    }\n\n    // Advance auto-transition using performance.now() like the original runner\n    if (animActiveRef.current && currentValuesRef.current && startValuesRef.current && targetValuesRef.current) {\n      const now = performance.now();\n      const elapsed = now - animStartTimeRef.current;\n      const durationMs = animDurationRef.current * 1000;\n      const t = Math.min(1, durationMs === 0 ? 1 : elapsed / durationMs);\n      const te = animEaseRef.current(t);\n      \n      // Interpolate all animatable values\n      for (const key of animatableKeys) {\n        const start = startValuesRef.current[key];\n        const target = targetValuesRef.current[key];\n        \n        if (typeof start === 'number' && typeof target === 'number') {\n          currentValuesRef.current[key] = start + (target - start) * te;\n        } else if (typeof start === 'string' && typeof target === 'string') {\n          // Handle color interpolation\n          try {\n            const startColor = new THREE.Color(start);\n            const targetColor = new THREE.Color(target);\n            const lerpedColor = startColor.clone().lerp(targetColor, te);\n            currentValuesRef.current[key] = `#${lerpedColor.getHexString()}`;\n          } catch {\n            // Invalid color, snap to target\n            currentValuesRef.current[key] = target;\n          }\n        }\n      }\n      \n      if (t >= 1) {\n        animActiveRef.current = false;\n        try { onCompleteRef.current && onCompleteRef.current(); } catch {}\n      }\n    }\n\n    // Use animated values only while an internal transition is active; otherwise use live props\n    const anim = animActiveRef.current ? currentValuesRef.current : null;\n    const radiusV = anim?.radius ?? radius;\n    const pointSizeV = anim?.pointSize ?? pointSize;\n    const sizeV = anim?.size ?? size;\n    const opacityV = anim?.opacity ?? opacity;\n    const rotationXV = anim?.rotationX ?? rotationX;\n    const rotationYV = anim?.rotationY ?? rotationY;\n    const rotationZV = anim?.rotationZ ?? rotationZ;\n    const randomishAmountV = anim?.randomishAmount ?? randomishAmount;\n    const randomishSpeedV = randomishSpeed; // Always use prop value (not animated)\n    const pulseSizeV = anim?.pulseSize ?? pulseSize;\n    const sineAmountV = anim?.sineAmount ?? sineAmount;\n    const sineSpeedV = sineSpeed; // Always use prop value (not animated)\n    const sineScaleV = sineScale; // Always use prop value (not animated)\n    const rippleAmountV = anim?.rippleAmount ?? rippleAmount;\n    const rippleSpeedV = rippleSpeed; // Always use prop value (not animated)\n    const rippleScaleV = rippleScale; // Always use prop value (not animated)\n    const surfaceRippleAmountV = anim?.surfaceRippleAmount ?? surfaceRippleAmount;\n    const surfaceRippleSpeedV = surfaceRippleSpeed; // Always use prop value (not animated)\n    const surfaceRippleScaleV = surfaceRippleScale; // Always use prop value (not animated)\n    const spinSpeedV = anim?.spinSpeed ?? spinSpeed;\n    const spinAxisXV = anim?.spinAxisX ?? spinAxisX;\n    const spinAxisYV = anim?.spinAxisY ?? spinAxisY;\n    // Masks should respond instantly to UI; use raw props\n    const maskRadiusV = maskRadius;\n    const maskFeatherV = maskFeather;\n    const gradientAngleV = anim?.gradientAngle ?? gradientAngle;\n    const sizeRandomnessV = anim?.sizeRandomness ?? sizeRandomness;\n    const glowStrengthV = anim?.glowStrength ?? glowStrength;\n    const glowRadiusFactorV = anim?.glowRadiusFactor ?? glowRadiusFactor;\n    const arcAltitudeV = anim?.arcAltitude ?? arcAltitude;\n    \n    // Color values\n    const pointColorV = anim?.pointColor ?? pointColor;\n    const gradientColor2V = anim?.gradientColor2 ?? gradientColor2;\n    const glowColorV = anim?.glowColor ?? glowColor;\n\n    // Update group transform directly to avoid re-renders\n    if (groupRef.current) {\n      groupRef.current.scale.set(sizeV, sizeV, sizeV);\n      groupRef.current.rotation.set(\n        THREE.MathUtils.degToRad(rotationXV),\n        THREE.MathUtils.degToRad(rotationYV),\n        THREE.MathUtils.degToRad(rotationZV)\n      );\n    }\n\n    // Morph context: B-lane target and progress\n    const mEnabled = Boolean(morph?.enabled);\n    const mProgress = THREE.MathUtils.clamp(morph?.progress ?? 0, 0, 1);\n    const toCfg = (mEnabled && morph?.to) ? morph.to : undefined;\n\n    for (let i = 0; i < uniformsArray.length; i++) {\n      const u = uniformsArray[i];\n      u.uTime.value = timeAccRef.current;\n      u.uRadius.value = radiusV * (1 + i * 0.2);\n      const radiusB = (toCfg?.radius as number | undefined) ?? radius;\n      u.uRadius2.value = radiusB * (1 + i * 0.2);\n      u.uPointSize.value = pointSizeV;\n      u.uPointSize2.value = (toCfg?.pointSize as number | undefined) ?? pointSize;\n      u.uViewportWidth.value = stateFrame.size.width;\n      u.uViewportHeight.value = stateFrame.size.height;\n      const cam = stateFrame.camera as THREE.PerspectiveCamera;\n      if (cam && typeof (cam as any).fov === 'number') {\n        u.uFov.value = (cam.fov * Math.PI) / 180;\n      }\n      u.uVolume.value = THREE.MathUtils.clamp(volume, 0, 1);\n      u.uEnableRandomish.value = 1; // Always enabled\n      const micEnv = THREE.MathUtils.clamp(micEnvelope, 0, 1);\n      const randomishAmountFinal = THREE.MathUtils.clamp(\n        (randomishAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(randomishMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uRandomishAmount.value = randomishAmountFinal;\n      const randomishAmountB = THREE.MathUtils.clamp(\n        (((toCfg?.randomishAmount as number | undefined) ?? randomishAmount) || 0) + micEnv * THREE.MathUtils.clamp(randomishMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uRandomishAmount2.value = randomishAmountB;\n      u.uEnableSine.value = 1; // Always enabled\n      const sineAmountFinal = THREE.MathUtils.clamp(\n        (sineAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(sineMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uSineAmount.value = sineAmountFinal;\n      const sineAmountB = THREE.MathUtils.clamp(\n        (((toCfg?.sineAmount as number | undefined) ?? sineAmount) || 0) + micEnv * THREE.MathUtils.clamp(sineMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uSineAmount2.value = sineAmountB;\n      u.uRandomishSpeed.value = randomishSpeedV;\n      u.uRandomishSpeed2.value = (toCfg?.randomishSpeed as number | undefined) ?? randomishSpeed;\n      u.uPulseSize.value = THREE.MathUtils.clamp(pulseSizeV, 0, 1);\n      u.uPulseSize2.value = THREE.MathUtils.clamp(((toCfg?.pulseSize as number | undefined) ?? pulseSize), 0, 1);\n      u.uOpacity.value = THREE.MathUtils.clamp(opacityV, 0, 1);\n      u.uSizeRandomness.value = THREE.MathUtils.clamp(sizeRandomnessV, 0, 1);\n      // Ripple\n      u.uEnableRipple.value = 1; // Always enabled\n      u.uRippleAmount.value = THREE.MathUtils.clamp(\n        (rippleAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(rippleMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uRippleSpeed.value = rippleSpeedV;\n      u.uRippleScale.value = rippleScaleV;\n      u.uRippleAmount2.value = THREE.MathUtils.clamp(\n        (((toCfg?.rippleAmount as number | undefined) ?? rippleAmount) || 0) + micEnv * THREE.MathUtils.clamp(rippleMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uRippleSpeed2.value = (toCfg?.rippleSpeed as number | undefined) ?? rippleSpeed;\n      u.uRippleScale2.value = (toCfg?.rippleScale as number | undefined) ?? rippleScale;\n      // Surface ripple\n      u.uEnableSurfaceRipple.value = 1; // Always enabled\n      u.uSurfaceRippleAmount.value = THREE.MathUtils.clamp(\n        (surfaceRippleAmountV ?? 0) + micEnv * THREE.MathUtils.clamp(surfaceRippleMicModAmount ?? 0, 0, 1),\n        0,\n        1\n      );\n      u.uSurfaceRippleSpeed.value = surfaceRippleSpeedV;\n      u.uSurfaceRippleScale.value = surfaceRippleScaleV;\n      u.uSurfaceRippleAmount2.value = THREE.MathUtils.clamp(\n        (((toCfg?.surfaceRippleAmount as number | undefined) ?? surfaceRippleAmount) || 0) + micEnv * THREE.MathUtils.clamp(surfaceRippleMicModAmount ?? 0, 0, 1),\n        0, 1\n      );\n      u.uSurfaceRippleSpeed2.value = (toCfg?.surfaceRippleSpeed as number | undefined) ?? surfaceRippleSpeed;\n      u.uSurfaceRippleScale2.value = (toCfg?.surfaceRippleScale as number | undefined) ?? surfaceRippleScale;\n      u.uEnableSpin.value = 1; // Always enabled\n      u.uSpinSpeed.value = spinSpeedV;\n      u.uSpinSpeed2.value = (toCfg?.spinSpeed as number | undefined) ?? spinSpeed;\n      u.uSpinAxisX.value = spinAxisXV;\n      u.uSpinAxisY.value = spinAxisYV;\n      u.uSpinAxisX2.value = (toCfg?.spinAxisX as number | undefined) ?? spinAxisX;\n      u.uSpinAxisY2.value = (toCfg?.spinAxisY as number | undefined) ?? spinAxisY;\n      // Mask that follows sphere center in screen space; blend A/B by morph progress\n      const maskRadiusB = THREE.MathUtils.clamp(((toCfg?.maskRadius as number | undefined) ?? maskRadius), 0, 1);\n      const maskFeatherB = THREE.MathUtils.clamp(((toCfg?.maskFeather as number | undefined) ?? maskFeather), 0, 1);\n      const maskRadiusMix = mEnabled ? (THREE.MathUtils.clamp(maskRadiusV, 0, 1) + (maskRadiusB - THREE.MathUtils.clamp(maskRadiusV, 0, 1)) * mProgress) : THREE.MathUtils.clamp(maskRadiusV, 0, 1);\n      const maskFeatherMix = mEnabled ? (THREE.MathUtils.clamp(maskFeatherV, 0, 1) + (maskFeatherB - THREE.MathUtils.clamp(maskFeatherV, 0, 1)) * mProgress) : THREE.MathUtils.clamp(maskFeatherV, 0, 1);\n      u.uMaskEnabled.value = (maskRadiusMix > 0 || maskFeatherMix > 0) ? 1 : 0;\n      u.uMaskInvert.value = maskInvert ? 1 : 0;\n      // Compute mask center from group's world position to ensure correct alignment\n      const worldCenter = new THREE.Vector3();\n      if (groupRef.current) {\n        groupRef.current.getWorldPosition(worldCenter);\n      } else {\n        worldCenter.set(0, 0, 0);\n      }\n      const centerNdc = worldCenter.clone().project(cam);\n      u.uMaskCenterNdc.value.set(centerNdc.x, centerNdc.y);\n      const minHalf = Math.min(stateFrame.size.width, stateFrame.size.height) * 0.5;\n      // Map normalized maskRadius to pixels, adjusted by zoom (keeps scale roughly stable)\n      u.uMaskRadiusPx.value = maskRadiusMix * minHalf * (1.0 / Math.max(1e-3, cam.zoom));\n      u.uMaskFeatherPx.value = maskFeatherMix * minHalf * (1.0 / Math.max(1e-3, cam.zoom));\n      // Sine noise\n      u.uSineSpeed.value = sineSpeedV;\n      u.uSineScale.value = sineScaleV;\n      u.uSineSpeed2.value = (toCfg?.sineSpeed as number | undefined) ?? sineSpeed;\n      u.uSineScale2.value = (toCfg?.sineScale as number | undefined) ?? sineScale;\n      // Color\n      // CPU-blend colors and gradient angle by morph progress\n      {\n        const colA = new THREE.Color(pointColorV);\n        const colB = new THREE.Color(((toCfg?.pointColor as string | undefined) ?? pointColor) || pointColor);\n        const colMix = colA.clone().lerp(colB, mProgress);\n        u.uColor.value.copy(colMix);\n        const gradA = new THREE.Color(gradientColor2V);\n        const gradB = new THREE.Color(((toCfg?.gradientColor2 as string | undefined) ?? gradientColor2) || gradientColor2);\n        const gradMix = gradA.clone().lerp(gradB, mProgress);\n        u.uColor2.value.copy(gradMix);\n        u.uEnableGradient.value = 1; // Always enabled\n        const angA = gradientAngleV;\n        const angB = (toCfg?.gradientAngle as number | undefined) ?? gradientAngle;\n        const angMix = angA + (angB - angA) * mProgress;\n        u.uGradientAngle.value = THREE.MathUtils.degToRad(angMix);\n      }\n      u.uGlowColor.value.set(glowColorV);\n      u.uGlowStrength.value = THREE.MathUtils.clamp(glowStrengthV, 0, 3);\n      u.uGlowRadiusFactor.value = Math.max(0, glowRadiusFactorV);\n      u.uGlowRadiusFactor2.value = Math.max(0, ((toCfg?.glowRadiusFactor as number | undefined) ?? glowRadiusFactor));\n      // Morph progress uniform\n      u.uMorphProgress.value = mEnabled ? mProgress : 0;\n      // Per-shell phase: deterministic from base seed and shell index\n      const phaseBase = Math.sin((seed + i * 17.23) * 12.9898) * 43758.5453;\n      const jitter = 1.0; // read directly from config in App if needed; default 1 here\n      u.uShellPhase.value = (phaseBase - Math.floor(phaseBase)) * jitter;\n      // Arcs\n      u.uArcsActive.value = arcsActive; // Always enabled\n      u.uArcCenters.value.set(centers);\n      u.uArcTangents.value.set(tangents);\n      u.uArcT0.value.set(t0);\n      u.uArcDur.value.set(dur);\n      u.uArcSpeed.value.set(spd);\n      u.uArcSpan.value.set(span);\n      u.uArcThick.value.set(thick);\n      u.uArcFeather.value.set(feath);\n      u.uArcBright.value.set(bright);\n      u.uArcAltitude.value = arcAltitudeV;\n    }\n  });\n\n  return (\n    <group ref={groupRef} scale={[size, size, size]} rotation={[THREE.MathUtils.degToRad(rotationX), THREE.MathUtils.degToRad(rotationY), THREE.MathUtils.degToRad(rotationZ)]}>\n      {uniformsRef.current!.map((u, i) => (\n        <group key={`shell-${i}`} renderOrder={i}>\n        {/* Single pass again: core only; bloom will provide glow */}\n        <points>\n          <bufferGeometry key={`${vertexCount}-${radius}-${seed}-${i}`}>\n            <bufferAttribute attach=\"attributes-position\" args={[positions, 3]} />\n            <bufferAttribute attach=\"attributes-aSeed\" args={[seeds, 1]} />\n          </bufferGeometry>\n          <shaderMaterial\n            vertexShader={vertexShader}\n            fragmentShader={fragmentShader}\n            uniforms={u as unknown as { [key: string]: THREE.IUniform }}\n            transparent\n            depthWrite={false}\n            depthTest\n            alphaTest={0.001}\n            premultipliedAlpha={false}\n            blending={THREE.NormalBlending}\n          />\n        </points>\n        </group>\n      ))}\n    </group>\n  );\n}\n\nexport default SphereWaveform;\n","export type AnimEase =\n  | 'linear'\n  | 'power1.in' | 'power1.out' | 'power1.inOut'\n  | 'power2.in' | 'power2.out' | 'power2.inOut'\n  | 'power3.in' | 'power3.out' | 'power3.inOut'\n  | 'power4.in' | 'power4.out' | 'power4.inOut'\n  | 'sine.in' | 'sine.out' | 'sine.inOut'\n  | 'expo.in' | 'expo.out' | 'expo.inOut'\n  | 'back.in' | 'back.out' | 'back.inOut'\n  | 'elastic.in' | 'elastic.out' | 'elastic.inOut'\n  | 'bounce.in' | 'bounce.out' | 'bounce.inOut';\n\nexport function getEaser(name: AnimEase | undefined): (t: number) => number {\n  switch (name) {\n    case 'linear':\n      return (t: number) => t;\n    case 'power1.in':\n      return (t: number) => t * t;\n    case 'power1.out':\n      return (t: number) => 1 - Math.pow(1 - t, 2);\n    case 'power1.inOut':\n      return (t: number) => (t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2);\n    case 'power2.in':\n      return (t: number) => t * t * t;\n    case 'power2.out':\n      return (t: number) => 1 - Math.pow(1 - t, 3);\n    case 'power2.inOut':\n      return (t: number) => (t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2);\n    case 'power3.in':\n      return (t: number) => t * t * t * t;\n    case 'power3.out':\n      return (t: number) => 1 - Math.pow(1 - t, 4);\n    case 'power3.inOut':\n      return (t: number) => (t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2);\n    case 'power4.in':\n      return (t: number) => t * t * t * t * t;\n    case 'power4.out':\n      return (t: number) => 1 - Math.pow(1 - t, 5);\n    case 'power4.inOut':\n      return (t: number) => (t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2);\n    case 'sine.in':\n      return (t: number) => 1 - Math.cos((t * Math.PI) / 2);\n    case 'sine.out':\n      return (t: number) => Math.sin((t * Math.PI) / 2);\n    case 'sine.inOut':\n      return (t: number) => -(Math.cos(Math.PI * t) - 1) / 2;\n    case 'expo.in':\n      return (t: number) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1)));\n    case 'expo.out':\n      return (t: number) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\n    case 'expo.inOut':\n      return (t: number) => {\n        if (t === 0 || t === 1) return t;\n        return t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;\n      };\n    case 'back.in':\n      return (t: number) => 2.7 * t * t * t - 1.7 * t * t;\n    case 'back.out':\n      return (t: number) => 1 + 2.7 * Math.pow(t - 1, 3) + 1.7 * Math.pow(t - 1, 2);\n    case 'back.inOut':\n      return (t: number) => {\n        const c1 = 1.70158;\n        const c2 = c1 * 1.525;\n        return t < 0.5\n          ? (Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2\n          : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;\n      };\n    case 'elastic.in':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);\n      };\n    case 'elastic.out':\n      return (t: number) => {\n        const c4 = (2 * Math.PI) / 3;\n        return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;\n      };\n    case 'elastic.inOut':\n      return (t: number) => {\n        const c5 = (2 * Math.PI) / 4.5;\n        return t === 0 ? 0 : t === 1 ? 1 : t < 0.5\n          ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2\n          : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5)) / 2 + 1;\n      };\n    case 'bounce.in':\n      return (t: number) => 1 - getEaser('bounce.out')(1 - t);\n    case 'bounce.out':\n      return (t: number) => {\n        const n1 = 7.5625;\n        const d1 = 2.75;\n        if (t < 1 / d1) {\n          return n1 * t * t;\n        } else if (t < 2 / d1) {\n          return n1 * (t -= 1.5 / d1) * t + 0.75;\n        } else if (t < 2.5 / d1) {\n          return n1 * (t -= 2.25 / d1) * t + 0.9375;\n        } else {\n          return n1 * (t -= 2.625 / d1) * t + 0.984375;\n        }\n      };\n    case 'bounce.inOut':\n      return (t: number) => t < 0.5\n        ? (1 - getEaser('bounce.out')(1 - 2 * t)) / 2\n        : (1 + getEaser('bounce.out')(2 * t - 1)) / 2;\n    default:\n      return (t: number) => t;\n  }\n}\n\n\n","import { useCallback, useEffect, useRef, useState } from 'react';\nimport type { SphereWaveformProps } from '../components/SphereWaveform';\nimport { getEaser, type AnimEase } from './easing';\n\nexport type WaveformConfig = Omit<SphereWaveformProps, 'transition' | 'morph'>;\n\nexport type AnimSpec = {\n  to: Partial<WaveformConfig>;\n  duration: number; // seconds\n  ease?: AnimEase;\n};\n\nexport function interpolateConfig(\n  from: WaveformConfig,\n  to: Partial<WaveformConfig>,\n  t: number\n): WaveformConfig {\n  const out: any = { ...from };\n  const mixNum = (a: number, b: number) => a + (b - a) * t;\n  const maybe = <T,>(v: T | undefined, fallback: T): T => (v === undefined ? fallback : v);\n\n  const numericKeys: Array<keyof WaveformConfig> = [\n    'vertexCount','volume','radius','pointSize','shellCount','seed','size','opacity',\n    'rotationX','rotationY','rotationZ',\n    'randomishAmount','randomishSpeed','pulseSize',\n    'rippleAmount','rippleSpeed','rippleScale',\n    'surfaceRippleAmount','surfaceRippleSpeed','surfaceRippleScale',\n    'spinSpeed','spinAxisX','spinAxisY',\n    'maskRadius','maskFeather',\n    'sineAmount','sineSpeed','sineScale',\n    'glowStrength','glowRadiusFactor','sizeRandomness',\n    'arcMaxCount','arcSpawnRate','arcDuration','arcSpeed','arcSpanDeg','arcThickness','arcFeather','arcBrightness','arcAltitude',\n    'advanceCount','advanceAmount',\n  ];\n\n  for (const key of numericKeys) {\n    const a = from[key] as unknown as number;\n    const b = maybe(to[key] as unknown as number | undefined, a);\n    if (typeof a === 'number' && typeof b === 'number') out[key] = mixNum(a, b);\n  }\n\n  const colorKeys: Array<keyof WaveformConfig> = ['pointColor','glowColor','gradientColor2'];\n  for (const key of colorKeys) {\n    const a = from[key] as unknown as string | undefined;\n    const b = (to[key] as unknown as string | undefined) ?? a;\n    if (typeof a === 'string' && typeof b === 'string') {\n      try {\n        // Keep output as hex string for UI friendliness\n        const ca = new (window as any).THREE.Color(a);\n        const cb = new (window as any).THREE.Color(b);\n        const cm = ca.clone().lerp(cb, t);\n        out[key] = `#${cm.getHexString()}`;\n      } catch {\n        out[key] = t < 0.5 ? a : b;\n      }\n    }\n  }\n\n  // Booleans are always-on; keep existing values (zero=off policy)\n  out.enableRandomishNoise = true;\n  out.enableSineNoise = true;\n  out.enableRippleNoise = true;\n  out.enableSurfaceRipple = true;\n  out.enableSpin = true;\n  out.enableGradient = true;\n  out.enableArcs = true;\n  out.maskEnabled = true;\n\n  // Non-animative flags\n  out.freezeTime = from.freezeTime;\n  out.advanceCount = from.advanceCount;\n  out.advanceAmount = from.advanceAmount;\n  out.maskInvert = from.maskInvert;\n  out.blendingMode = from.blendingMode;\n\n  return out as WaveformConfig;\n}\n\nexport function useMorphAnimator(opts?: {\n  ease?: AnimEase;\n  onStart?: () => void;\n  onUpdate?: (progress: number) => void;\n  onComplete?: (final: WaveformConfig) => void;\n}) {\n  const easeFnRef = useRef<(t: number) => number>(getEaser(opts?.ease ?? 'power2.inOut'));\n  const rafRef = useRef<number | null>(null);\n  const startRef = useRef<number>(0);\n  const durRef = useRef<number>(0);\n  const fromRef = useRef<WaveformConfig | null>(null);\n  const toRef = useRef<Partial<WaveformConfig> | null>(null);\n\n  const [enabled, setEnabled] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [toState, setToState] = useState<Partial<WaveformConfig> | undefined>(undefined);\n\n  useEffect(() => {\n    easeFnRef.current = getEaser(opts?.ease ?? 'power2.inOut');\n  }, [opts?.ease]);\n\n  const cancel = useCallback(() => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    rafRef.current = null;\n    setEnabled(false);\n  }, []);\n\n  const play = useCallback((anim: AnimSpec, from: WaveformConfig) => {\n    cancel();\n    fromRef.current = { ...from };\n    toRef.current = { ...anim.to };\n    durRef.current = Math.max(0, anim.duration) * 1000;\n    easeFnRef.current = getEaser(anim.ease ?? opts?.ease ?? 'power2.inOut');\n\n    setToState(anim.to);\n    setEnabled(true);\n    setProgress(0);\n    opts?.onStart?.();\n\n    startRef.current = performance.now();\n    const tick = () => {\n      const now = performance.now();\n      const t = durRef.current === 0 ? 1 : Math.min(1, (now - startRef.current) / durRef.current);\n      const te = easeFnRef.current(t);\n      setProgress(te);\n      opts?.onUpdate?.(te);\n      if (t < 1) {\n        rafRef.current = requestAnimationFrame(tick);\n      } else {\n        rafRef.current = null;\n        setEnabled(false);\n        const final = interpolateConfig(fromRef.current!, toRef.current!, 1);\n        opts?.onComplete?.(final);\n      }\n    };\n    rafRef.current = requestAnimationFrame(tick);\n  }, [cancel, opts]);\n\n  const morph = enabled\n    ? { enabled: true, progress, to: toState }\n    : { enabled: false, progress: 0 };\n\n  return { morph, play, cancel, playing: enabled, progress } as const;\n}\n\nexport class MorphController {\n  private easeFn: (t: number) => number;\n  private raf: number | null = null;\n  private start = 0;\n  private durMs = 0;\n  private from!: WaveformConfig;\n  private to!: Partial<WaveformConfig>;\n\n  constructor(ease: AnimEase = 'power2.inOut') {\n    this.easeFn = getEaser(ease);\n  }\n\n  cancel() {\n    if (this.raf) cancelAnimationFrame(this.raf);\n    this.raf = null;\n  }\n\n  async play(anim: AnimSpec, from: WaveformConfig, onProgress: (p: number, to: Partial<WaveformConfig>) => void): Promise<WaveformConfig> {\n    this.cancel();\n    this.from = { ...from };\n    this.to = { ...anim.to };\n    this.durMs = Math.max(0, anim.duration) * 1000;\n    this.easeFn = getEaser(anim.ease ?? 'power2.inOut');\n    this.start = performance.now();\n\n    return new Promise<WaveformConfig>((resolve) => {\n      const tick = () => {\n        const now = performance.now();\n        const t = this.durMs === 0 ? 1 : Math.min(1, (now - this.start) / this.durMs);\n        const te = this.easeFn(t);\n        onProgress(te, this.to);\n        if (t < 1) {\n          this.raf = requestAnimationFrame(tick);\n        } else {\n          this.raf = null;\n          resolve(interpolateConfig(this.from, this.to, 1));\n        }\n      };\n      this.raf = requestAnimationFrame(tick);\n    });\n  }\n}\n\n\n"],"names":["REACT_ELEMENT_TYPE","REACT_FRAGMENT_TYPE","jsxProd","type","config","maybeKey","key","propName","reactJsxRuntime_production","getComponentNameFromType","REACT_CLIENT_REFERENCE","REACT_PROFILER_TYPE","REACT_STRICT_MODE_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_ACTIVITY_TYPE","REACT_PORTAL_TYPE","REACT_CONTEXT_TYPE","REACT_CONSUMER_TYPE","REACT_FORWARD_REF_TYPE","innerType","REACT_MEMO_TYPE","REACT_LAZY_TYPE","testStringCoercion","value","checkKeyStringCoercion","JSCompiler_inline_result","JSCompiler_temp_const","JSCompiler_inline_result$jscomp$0","getTaskName","name","getOwner","dispatcher","ReactSharedInternals","UnknownOwner","hasValidKey","hasOwnProperty","getter","defineKeyPropWarningGetter","props","displayName","warnAboutAccessingKey","specialPropKeyWarningShown","elementRefGetterWithDeprecationWarning","componentName","didWarnAboutElementRef","ReactElement","self","source","owner","debugStack","debugTask","jsxDEVImpl","isStaticChildren","children","isArrayImpl","validateChildKeys","keys","k","didWarnAboutKeySpread","node","React","require$$0","createTask","callStackForError","unknownOwnerDebugStack","unknownOwnerDebugTask","reactJsxRuntime_development","trackActualOwner","jsxRuntimeModule","require$$1","generateFibonacciSpherePoints","vertexCount","radius","seed","count","r","goldenAngle","positions","seeds","i","t","y","yy","radiusAtY","theta","x","z","pr","lcg","index","state","vertexShader","fragmentShader","getEaser","c2","c4","c5","SphereWaveform","volume","pointSize","shellCount","freezeTime","advanceCount","advanceAmount","size","opacity","rotationX","rotationY","rotationZ","enableRandomishNoise","randomishAmount","enableSineNoise","sineAmount","pulseSize","enableSpin","spinSpeed","randomishSpeed","enableRippleNoise","rippleAmount","rippleSpeed","rippleScale","enableSurfaceRipple","surfaceRippleAmount","surfaceRippleSpeed","surfaceRippleScale","spinAxisX","spinAxisY","maskEnabled","maskRadius","maskFeather","maskInvert","sineSpeed","sineScale","pointColor","glowColor","glowStrength","glowRadiusFactor","enableGradient","gradientColor2","gradientAngle","sizeRandomness","enableArcs","arcMaxCount","arcSpawnRate","arcDuration","arcSpeed","arcSpanDeg","arcThickness","arcFeather","arcBrightness","arcAltitude","micEnvelope","randomishMicModAmount","sineMicModAmount","rippleMicModAmount","surfaceRippleMicModAmount","transition","morph","groupRef","useRef","uniformsRef","prevNowRef","timeAccRef","lastAdvanceRef","arcsRef","animatableKeys","currentValuesRef","startValuesRef","targetValuesRef","animActiveRef","animStartTimeRef","animDurationRef","animEaseRef","onStartRef","onCompleteRef","previousPropsRef","useEffect","enabled","duration","ease","currentProps","currentVisualState","changed","previousValue","newValue","useMemo","arr","THREE","useFrame","stateFrame","uniformsArray","now","dt","diff","arcs","maxArcs","expected","spawns","rem","s","u","v","cx","cy","cz","center","rand","tangent","centers","tangents","t0","dur","spd","span","thick","feath","bright","arcsActive","a","idx3","elapsed","durationMs","te","start","target","startColor","targetColor","lerpedColor","anim","radiusV","pointSizeV","sizeV","opacityV","rotationXV","rotationYV","rotationZV","randomishAmountV","randomishSpeedV","pulseSizeV","sineAmountV","sineSpeedV","sineScaleV","rippleAmountV","rippleSpeedV","rippleScaleV","surfaceRippleAmountV","surfaceRippleSpeedV","surfaceRippleScaleV","spinSpeedV","spinAxisXV","spinAxisYV","maskRadiusV","maskFeatherV","gradientAngleV","sizeRandomnessV","glowStrengthV","glowRadiusFactorV","arcAltitudeV","pointColorV","gradientColor2V","glowColorV","mEnabled","mProgress","toCfg","radiusB","cam","micEnv","randomishAmountFinal","randomishAmountB","sineAmountFinal","sineAmountB","maskRadiusB","maskFeatherB","maskRadiusMix","maskFeatherMix","worldCenter","centerNdc","minHalf","colA","colB","colMix","gradA","gradB","gradMix","angA","angB","angMix","phaseBase","jitter","jsx","jsxs","interpolateConfig","from","to","out","mixNum","b","maybe","fallback","numericKeys","colorKeys","ca","cb","cm","useMorphAnimator","opts","easeFnRef","rafRef","startRef","durRef","fromRef","toRef","setEnabled","useState","progress","setProgress","toState","setToState","cancel","useCallback","play","_a","tick","final","_b","MorphController","onProgress","resolve"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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","x_google_ignoreList":[0,1,2]}